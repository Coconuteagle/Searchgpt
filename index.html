<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>검색 기반 Gemini 챗봇</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <script src="config.js"></script>
    <style>
        body {
            transition: background-color 0.3s, color 0.3s;
        }
        .dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .chat-container {
            height: calc(100vh - 180px); /* Adjusted for potential footer/header */
            min-height: 400px;
        }
        .user-message {
            background-color: #e3f2fd;
            border-radius: 18px 18px 2px 18px;
            /* Align user messages to the right */
            margin-left: auto;
            margin-right: 0;
        }
        .bot-message {
            background-color: #f1f1f1;
            border-radius: 18px 18px 18px 2px;
             /* Align bot messages to the left */
            margin-left: 0;
            margin-right: auto;
        }
        .dark .user-message {
            background-color: #2d3748;
        }
        .dark .bot-message {
            background-color: #4a5568;
        }
        /* Progress Bar Styles */
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden; /* Ensure progress bar stays within bounds */
        }
        .progress-bar {
            height: 100%;
            border-radius: 4px 0 0 4px; /* Slightly rounded left edge */
            width: 0%;
            background-color: #4299e1;
            transition: width 0.3s ease-in-out; /* Smoother transition */
        }
        .dark .progress-container {
            background-color: #2d3748;
        }
        .progress-status {
            margin-top: 5px;
            font-size: 12px;
            color: #718096;
            text-align: center; /* Center status text */
        }
        .dark .progress-status {
            color: #a0aec0;
        }
        /* Source Link Styles */
        .source-link {
            color: #3182ce;
            text-decoration: underline;
            word-break: break-all; /* Break long links */
        }
        .dark .source-link {
            color: #90cdf4;
        }
        .source-link:hover {
            text-decoration: none; /* Optional: remove underline on hover */
        }
        /* Typing Indicator Styles */
        .ellipsis {
            display: inline-block;
            width: 60px; /* Fixed width for alignment */
            text-align: left;
        }
        .typing-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: currentColor; /* Use current text color */
            margin-right: 4px;
            animation: typing 1s infinite;
        }
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typing {
            0%, 100% { opacity: 0.3; transform: translateY(0); }
            50% { opacity: 1; transform: translateY(-2px); }
        }
         /* Print Styles */
        @media print {
            .no-print { display: none !important; }
            body { background-color: #fff; color: #000; }
            .dark { background-color: #fff; color: #000; } /* Force light mode for print */
            .dark .user-message, .dark .bot-message { background-color: #f1f1f1; color: #000; }
            .user-message, .bot-message { background-color: #f1f1f1; }
            .chat-container { height: auto; max-height: none; overflow: visible; }
            .source-link { color: #0000EE; text-decoration: underline; } /* Standard link blue for print */
            .print-break { page-break-before: always; }
             #chat-form, #progress-section, #theme-toggle { display: none; } /* Hide form/controls */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="flex justify-between items-center mb-6 no-print">
            <h1 class="text-3xl font-bold text-gray-800 dark:text-white">검색 기반 Gemini 챗봇</h1>
            <div class="flex space-x-4">
                <button id="theme-toggle" class="px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition focus:outline-none focus:ring-2 focus:ring-gray-500">
                    <i class="fas fa-moon"></i> </button>
                 <button onclick="window.print()" class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <i class="fas fa-print"></i>
                </button>
            </div>
        </div>

        <div id="chat-box" class="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <div id="chat-messages" class="chat-container p-4 overflow-y-auto space-y-4">
                <div class="bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl">
                    <p>안녕하세요! 검색 기반 Gemini 챗봇입니다. 궁금한 점이 있으시면 질문해주세요. 제가 구글 검색과 웹페이지 분석(실패 시 요약 정보 활용)을 통해 답변해 드리겠습니다.</p>
                </div>
            </div>

            <div id="chat-form" class="p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 no-print">
                <div class="max-w-3xl mx-auto">
                    <div id="progress-section" class="mb-3 hidden">
                        <div id="progress-status" class="progress-status"></div>
                        <div class="progress-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <input type="text" id="user-input" class="flex-grow px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" placeholder="질문을 입력하세요...">
                        <button id="send-button" class="px-4 py-2 bg-blue-500 text-white rounded-r-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50" aria-label="Send message">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-6 text-sm text-gray-600 dark:text-gray-400 text-center no-print">
            <p>© 2025 검색 기반 Gemini 챗봇 by 수현</p>
        </div>
    </div>

   <script>
        // --- Basic Setup ---
        const DEBUG = true; // Enable console logging
        function log(...args) {
            if (DEBUG) {
                console.log(`[챗봇 로그 ${new Date().toLocaleTimeString()}]`, ...args);
            }
        }

        // Check if API keys are loaded from config.js
        if (typeof apiKeys === 'undefined') {
            console.error("API Keys not found! Make sure config.js is loaded correctly and defines the 'apiKeys' object.");
            alert("API Keys 설정 파일을 찾을 수 없습니다. config.js 파일이 올바르게 로드되었는지 확인하세요.");
        }

        // --- DOM Elements ---
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const progressSection = document.getElementById('progress-section');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const body = document.body;

        // --- Dark Mode ---
        // (다크 모드 관련 코드는 변경 없음 - 생략)
        function applyTheme(isDark) {
            if (isDark) {
                body.classList.add('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
            } else {
                body.classList.remove('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
            }
        }
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
        let currentModeIsDark = localStorage.getItem('dark-mode') === 'true' || (localStorage.getItem('dark-mode') === null && prefersDark.matches);
        applyTheme(currentModeIsDark);

        themeToggleBtn.addEventListener('click', () => {
            currentModeIsDark = !currentModeIsDark;
            localStorage.setItem('dark-mode', currentModeIsDark ? 'true' : 'false');
            applyTheme(currentModeIsDark);
        });
         prefersDark.addEventListener('change', (e) => {
              if (localStorage.getItem('dark-mode') === null) {
                  currentModeIsDark = e.matches;
                  applyTheme(currentModeIsDark);
              }
         });


        // --- Cache System ---
        // (캐시 관련 코드는 변경 없음 - 생략)
        const cache = {
            search: new Map(),
            crawl: new Map(),
            maxAge: 30 * 60 * 1000, // 30 minutes validity
            getSearch(query) {
                const item = this.search.get(query);
                if (item && (Date.now() - item.timestamp < this.maxAge)) {
                    log('Search cache hit:', query);
                    return item.data;
                }
                log('Search cache miss:', query);
                return null;
            },
            setSearch(query, data) {
                this.search.set(query, { data, timestamp: Date.now() });
                log('Search cache set:', query);
            },
            getCrawl(url) {
                const item = this.crawl.get(url);
                if (item && (Date.now() - item.timestamp < this.maxAge)) {
                    log('Crawl cache hit:', url);
                    return item.data;
                }
                log('Crawl cache miss:', url);
                return null;
            },
            setCrawl(url, data) {
                this.crawl.set(url, { data, timestamp: Date.now() });
                log('Crawl cache set:', url, 'Length:', data?.length);
            }
        };


        // --- UI Update Functions ---
        // (UI 업데이트 함수들은 변경 없음 - escapeHtml, addUserMessage, addBotMessage, addLoadingMessage, updateLoadingMessage, removeLoadingMessage, updateProgress, scrollToBottom, setLoadingState - 생략)
        function escapeHtml(unsafe) {
            if (unsafe === null || typeof unsafe === 'undefined') return '';
             return unsafe
                  .toString()
                  .replace(/&/g, "&amp;")
                  .replace(/</g, "&lt;")
                  .replace(/>/g, "&gt;")
                  .replace(/"/g, "&quot;")
                  .replace(/'/g, "&#039;");
         }

        function addUserMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'user-message p-3 md:p-4 text-gray-800 dark:text-gray-200 max-w-3xl ml-auto mb-4';
            messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addBotMessage(message, isHTML = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-3 md:p-4 text-gray-800 dark:text-gray-200 max-w-3xl mr-auto mb-4';
            if (isHTML) {
                 const sanitizedHTML = message.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); // Basic sanitize
                 messageDiv.innerHTML = sanitizedHTML;
            } else {
                messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            }
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

         function addLoadingMessage() {
            const existingLoading = document.getElementById('loading-message');
            if (existingLoading) return existingLoading; // Don't add multiple loading messages

            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl mr-auto mb-4';
            messageDiv.id = 'loading-message';
            messageDiv.innerHTML = `<span>작업 중</span><span class="ellipsis"><span class="typing-dot"></span><span class="typing-dot"></span><span class="typing-dot"></span></span>`; // Initial state
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

         function updateLoadingMessage(message) {
            let loadingMessage = document.getElementById('loading-message');
            if (!loadingMessage) {
                 loadingMessage = addLoadingMessage(); // Ensure it exists
            }
            // Update the text part of the loading message
            const textSpan = loadingMessage.querySelector('span:first-child');
            if(textSpan) {
                textSpan.textContent = escapeHtml(message);
            }
         }


        function removeLoadingMessage() {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.remove();
            }
        }

        function updateProgress(percent, statusText) {
             progressBar.style.width = `${Math.min(100, Math.max(0, percent))}%`;
             progressStatus.textContent = statusText;

             // Make progress bar visible if needed
             if (percent > 0 && progressSection.classList.contains('hidden')) {
                 progressSection.classList.remove('hidden');
             }

             // Automatically hide progress bar when complete after a delay
             if (percent >= 100) {
                 setTimeout(() => {
                     // Check again in case a new process started quickly
                     if (progressBar.style.width === '100%') {
                          progressSection.classList.add('hidden');
                          progressBar.style.width = '0%';
                          progressStatus.textContent = '';
                     }
                 }, 1500); // Hide after 1.5 seconds
             } else if (percent <= 0) { // Hide immediately if reset to 0
                  progressSection.classList.add('hidden');
                  progressBar.style.width = '0%';
                  progressStatus.textContent = '';
             }
        }


        function scrollToBottom() {
             setTimeout(() => {
                 chatMessages.scrollTop = chatMessages.scrollHeight;
             }, 50); // Short delay allows DOM to update
        }

        function setLoadingState(isLoading) {
             if (isLoading) {
                 sendButton.disabled = true;
                 userInput.disabled = true;
                 sendButton.classList.add('disabled:opacity-50');
                 addLoadingMessage(); // Add the loading message element
                 updateProgress(0, '시작 중...'); // Reset progress
             } else {
                 sendButton.disabled = false;
                 userInput.disabled = false;
                 sendButton.classList.remove('disabled:opacity-50');
                 removeLoadingMessage(); // Remove the loading message element
                 // Don't reset progress here, let updateProgress(100, ...) handle hiding
             }
         }


        // --- Google Search API Call ---
        // (googleSearch 함수는 변경 없음 - 생략)
        async function googleSearch(query, numResults = 8) { // Added numResults parameter
            const googleApiKey = apiKeys?.GOOGLE_API_KEY;
            const searchEngineId = apiKeys?.SEARCH_ENGINE_ID;
            if (!googleApiKey || !searchEngineId) {
                 throw new Error("Google Search API Key or Search Engine ID is missing in config.js");
            }

            // Progress update is handled by the caller (processMessage)

            const cachedResults = cache.getSearch(query);
            if (cachedResults) {
                log(`Using cached search results for: ${query}`);
                return cachedResults;
            }

            try {
                const apiUrl = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&num=${numResults}`;
                log("Google Search API Request:", apiUrl);
                const response = await fetch(apiUrl);
                const data = await response.json();

                if (!response.ok || data.error) {
                    log('Google Search API Error:', data.error || `HTTP ${response.status} ${response.statusText}`);
                    throw new Error(`Google 검색 API 오류: ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }

                if (!data.items || data.items.length === 0) {
                     log("Google Search: No results for query:", query);
                    return [];
                }
                const results = data.items.map(item => ({
                    title: item.title,
                    link: item.link,
                    snippet: item.snippet,
                    pagemap: item.pagemap // Keep pagemap if needed later
                }));
                cache.setSearch(query, results); // Cache the results
                return results;
            } catch (error) {
                log('Exception during Google Search:', error.message, error.stack);
                throw error; // Re-throw the error to be caught by the caller
            }
        }


        // --- Web Crawling ---
        // (crawlWebpage 및 crawlWebpages 함수는 변경 없음 - 생략)
        const PROXY_COOLDOWN_MS = 3 * 60 * 1000; // 3 minutes cooldown period
        const proxies = [
             { name: 'corsproxy.io', url: (targetUrl) => `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`, cooldownUntil: 0 },
             { name: 'allorigins', url: (targetUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`, cooldownUntil: 0 },
        ];

        async function crawlWebpage(url, attempt = 0) {
            const cachedContent = cache.getCrawl(url);
            if (cachedContent) {
                // Return cached data immediately if valid
                return cachedContent;
            }

            const availableProxies = proxies.filter(p => Date.now() >= (p.cooldownUntil || 0));

            if (availableProxies.length === 0) {
                const soonestAvailable = proxies.reduce((soonest, p) => ((p.cooldownUntil || 0) < (soonest.cooldownUntil || 0) ? p : soonest), proxies[0]);
                const waitTime = soonestAvailable ? Math.ceil(((soonestAvailable.cooldownUntil || 0) - Date.now()) / 1000) : 'N/A';
                log(`Crawl failed: All proxies on cooldown. URL: ${url}. Next available in ~${waitTime}s`);
                return `크롤링 실패 (모든 프록시 쿨다운 중, 약 ${waitTime}초 후 재시도 가능): ${url}`;
            }

            const maxRetriesForUrl = availableProxies.length;
            if (attempt >= maxRetriesForUrl) {
                log(`Crawl max retries reached (${maxRetriesForUrl}) for URL: ${url}`);
                return `크롤링 실패 (최대 재시도): ${url}`;
            }

            const proxy = availableProxies[attempt];
            log(`[${proxy.name}] Crawl attempt ${attempt + 1}/${maxRetriesForUrl}: ${url}`);

            try {
                if (!url || !url.startsWith('http')) {
                     log(`[${proxy.name}] Skipping crawl (Invalid URL): ${url}`);
                    throw new Error(`유효하지 않은 URL: ${url}`);
                }
                 const path = url.split('?')[0];
                 const fileExtension = path.includes('.') ? path.split('.').pop().toLowerCase() : '';
                const nonHtmlExtensions = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'zip', 'rar', 'jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'mp3', 'mp4', 'avi', 'mov', 'exe', 'dmg'];
                if (nonHtmlExtensions.includes(fileExtension)) {
                     log(`[${proxy.name}] Skipping crawl (File type ${fileExtension}): ${url}`);
                    return `크롤링 건너뜀 (파일 형식 ${fileExtension.toUpperCase()}): ${url}`;
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                     log(`[${proxy.name}] Timeout (15s) occurred for URL: ${url}`);
                 }, 15000); // 15 second timeout

                const proxyUrl = proxy.url(url);
                 const headers = { // Use realistic browser headers
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
                    'Upgrade-Insecure-Requests': '1',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'cross-site', // Changed from none/same-origin
                 };


                const response = await fetch(proxyUrl, {
                    signal: controller.signal,
                     headers: headers,
                     mode: 'cors', // Required for cross-origin requests via proxy
                     referrerPolicy: 'strict-origin-when-cross-origin' // Common browser policy
                 });
                clearTimeout(timeoutId);

                if (!response.ok) {
                    let errorBody = '';
                    try { errorBody = await response.text(); } catch (_) {} // Try to get error body
                    log(`[${proxy.name}] HTTP Error ${response.status} (${response.statusText}). URL: ${url}. Response snippet: ${errorBody.substring(0, 200)}...`);
                    throw new Error(`HTTP 오류 ${response.status}`);
                }

                const contentType = response.headers.get('content-type') || '';
                log(`[${proxy.name}] Response Content-Type: ${contentType}. URL: ${url}`);
                 if (!contentType.includes('text/html') && !contentType.includes('application/xhtml+xml') && !contentType.includes('text/plain')) {
                     // Handle JSON or XML specifically if needed, otherwise mark as unsupported
                     if (contentType.includes('application/json')) {
                          try {
                             const json = await response.json();
                             const textContent = `JSON 데이터:\n${JSON.stringify(json, null, 2)}`.substring(0, 8000);
                             cache.setCrawl(url, textContent); // Cache JSON content
                             log(`[${proxy.name}] JSON data processed successfully. URL: ${url}`);
                             return textContent;
                          } catch (e) {
                             log(`[${proxy.name}] JSON parsing error. Content-Type: ${contentType}, URL: ${url}`, e);
                             return `JSON 파싱 오류. Content-Type: ${contentType}, URL: ${url}`;
                          }
                     } else if (contentType.includes('xml') && !contentType.includes('xhtml')) {
                         try {
                             const xmlText = await response.text();
                             const textContent = `XML 데이터:\n${xmlText}`.substring(0, 8000);
                             cache.setCrawl(url, textContent); // Cache XML content
                             log(`[${proxy.name}] XML data processed successfully. URL: ${url}`);
                             return textContent;
                         } catch(e) {
                             log(`[${proxy.name}] XML parsing error. Content-Type: ${contentType}, URL: ${url}`, e);
                             return `XML 파싱 오류. Content-Type: ${contentType}, URL: ${url}`;
                         }
                     }
                     // If neither HTML, plain text, JSON, nor XML
                     log(`[${proxy.name}] Unsupported Content-Type: ${contentType}, URL: ${url}`);
                     return `지원하지 않는 콘텐츠 타입 (${contentType}): ${url}`;
                 }


                const html = await response.text();
                 if (!html || html.trim().length === 0) {
                     log(`[${proxy.name}] Empty response or no content. URL: ${url}`);
                     throw new Error('빈 응답 또는 내용 없음');
                 }


                 const parser = new DOMParser();
                 const doc = parser.parseFromString(html, 'text/html');

                 // Enhanced Content Extraction
                 const title = doc.querySelector('title')?.textContent.trim() || url;
                 const metaDescription = doc.querySelector('meta[name="description"]')?.getAttribute('content')?.trim() || '';

                 // Remove unwanted elements more aggressively
                 const elementsToRemove = ['script', 'style', 'svg', 'img', 'picture', 'video', 'audio', 'iframe', 'nav', 'header', 'footer', 'aside', 'form', 'noscript', 'button', 'input', 'select', 'textarea', 'label', 'canvas', 'map', 'object', 'embed', '.advertisement', '.ad', '#ad', '.banner', '.popup', '.modal', '.sidebar', '.social-links', '.share-buttons', '.cookie-consent', '[aria-hidden="true"]']; // Added common selectors
                 elementsToRemove.forEach(selector => {
                     try { // Add try-catch for potentially invalid selectors
                         doc.querySelectorAll(selector).forEach(el => el.remove());
                     } catch (e) {
                         log(`[${proxy.name}] CSS Selector Error Ignored (${selector}), URL: ${url}:`, e.message);
                     }
                 });

                 // Try to find main content area, fallback to body
                  let mainContent = doc.querySelector('main') ||
                                   doc.querySelector('article') ||
                                   doc.querySelector('[role="main"]') ||
                                   // Add more common content selectors
                                   doc.querySelector('.content, .main-content, .post-content, .entry-content, #content, #main, .article-body, .entry, .page-content'); // Common class/ID names

                  if (!mainContent || mainContent.textContent.trim().length < 100) { // Use body if main content seems too short
                      log(`[${proxy.name}] Main content seems small or missing, using document body. URL: ${url}`);
                      mainContent = doc.body;
                  }


                 // Refined Text Extraction Logic
                  let text = '';
                  const significantTags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre', 'div', 'td']; // Tags likely to contain content blocks

                  function extractTextNodes(node) {
                      let nodeText = '';
                      if (!node) return ''; // Guard against null nodes passed unexpectedly
                      for (const child of node.childNodes) {
                          if (child.nodeType === Node.TEXT_NODE) {
                              nodeText += child.textContent; // Append text content directly
                          } else if (child.nodeType === Node.ELEMENT_NODE) {
                               // Check if the element is likely block-level or significant
                               const tagName = child.tagName.toLowerCase();
                               let displayStyle = 'inline'; // Default
                               try { // getComputedStyle can fail in some isolated browser/DOM contexts
                                   displayStyle = window.getComputedStyle(child).display;
                               } catch(e) {
                                   log(`[${proxy.name}] getComputedStyle error ignored (${tagName}), URL: ${url}:`, e.message);
                                    // Simple fallback if style check fails
                                    if (['p','h1','h2','h3','h4','h5','h6','li','blockquote','pre','div','td','tr','ul','ol','section','article','aside','nav','header','footer'].includes(tagName)) {
                                        displayStyle = 'block';
                                    }
                               }


                               // Add newline BEFORE processing block/significant elements if needed
                               if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && text.length > 0 && !text.endsWith('\n')) {
                                   nodeText += '\n';
                               }

                               nodeText += extractTextNodes(child); // Recursively extract text

                               // Add newline AFTER processing block/significant elements if needed
                               if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && !nodeText.endsWith('\n')) {
                                   nodeText += '\n';
                               }
                           }
                      }
                      return nodeText;
                  }

                  text = extractTextNodes(mainContent);


                 // Clean up whitespace more effectively
                 text = text.replace(/(\s*\n\s*){3,}/g, '\n\n') // Reduce multiple newlines to max two
                           .replace(/[ \t]{2,}/g, ' ')         // Collapse multiple spaces/tabs to one space
                           .replace(/^\s+|\s+$/gm, '')        // Trim whitespace from start/end of each line
                           .trim();                           // Trim leading/trailing whitespace from the whole string

                  // Prepend Title and Description
                  text = `제목: ${title}\n${metaDescription ? '설명: ' + metaDescription + '\n' : ''}\n---\n\n${text}`;


                 // Truncate if too long
                 const maxLength = 8000; // Gemini context limit consideration
                 if (text.length > maxLength) {
                     text = text.substring(0, maxLength) + '... [내용 중략됨]';
                     log(`[${proxy.name}] Crawled content truncated (>${maxLength} chars). URL: ${url}`);
                 }

                  if (!text || text.length < 50) { // Check for minimal content length
                      log(`[${proxy.name}] Insufficient meaningful content extracted (length ${text?.length}). URL: ${url}`);
                      // Still return the short text; Gemini might find something, or it will be filtered later.
                  }


                 log(`[${proxy.name}] Crawl successful. URL: ${url}, Length: ${text.length}`);
                 cache.setCrawl(url, text); // Cache the successful result

                 // Reset cooldown for this proxy if it was on cooldown before? No, successful attempt doesn't reset others' cooldowns.
                 return text;

            } catch (error) {
                 log(`[${proxy.name}] Exception during crawl attempt ${attempt + 1}/${maxRetriesForUrl} for '${url}':`, error.message, error.stack);

                 // Apply cooldown to the failed proxy
                 proxy.cooldownUntil = Date.now() + PROXY_COOLDOWN_MS;
                 log(`[${proxy.name}] Proxy cooldown set (${PROXY_COOLDOWN_MS / 1000}s). URL: ${url}`);

                 // Retry with the next available proxy
                 return crawlWebpage(url, attempt + 1); // *** IMPORTANT: Return the recursive call ***
             }
        }

        async function crawlWebpages(pagesToCrawl, progressStart, progressEnd) {
             const totalSites = pagesToCrawl.length;
             if (totalSites === 0) return []; // Handle empty input

             log(`Starting crawl/analysis for ${totalSites} sites.`);
             updateProgress(progressStart, `웹페이지 분석 시작 (0/${totalSites})...`);

             let completedCount = 0;
             const crawlPromises = pagesToCrawl.map(async (pageInfo, index) => {
                 try {
                      const content = await crawlWebpage(pageInfo.link); // crawlWebpage handles retries internally
                      completedCount++;
                      // Calculate progress within the allocated range
                      const currentProgress = progressStart + Math.floor(completedCount * (progressEnd - progressStart) / totalSites);
                      updateProgress(currentProgress, `${totalSites}개 중 ${completedCount}개 사이트 분석 완료`);
                      log(`Site ${index + 1}/${totalSites} analysis complete: ${pageInfo.link}, Result length: ${content?.length}`);
                      // Return a structured result including original info and content
                      return { ...pageInfo, content: content || '[내용 없음]', status: 'fulfilled' }; // Ensure content is never undefined
                 } catch (error) {
                      // This catch is a safeguard, crawlWebpage should handle most errors
                      log(`Unexpected error during crawlWebpages mapping (Site ${pageInfo.link}):`, error.message, error.stack);
                      completedCount++;
                       const currentProgress = progressStart + Math.floor(completedCount * (progressEnd - progressStart) / totalSites);
                       updateProgress(currentProgress, `${totalSites}개 중 ${completedCount}개 사이트 분석 완료 (오류 포함)`);
                      // Return error information consistently
                      return { ...pageInfo, content: `크롤링 중 예상치 못한 오류: ${error.message}`, status: 'rejected' };
                 }
             });

             // Use Promise.allSettled to ensure all promises complete, regardless of success/failure
             const results = await Promise.allSettled(crawlPromises);
             log('All site crawl/analysis attempts finished (Promise.allSettled complete).');
             updateProgress(progressEnd, '분석 완료, 응답 생성 준비 중...'); // Mark end of crawl phase

             // Process settled results to return a consistent array format
             return results.map((result, index) => {
                 if (result.status === 'fulfilled') {
                     // Log success details for debugging
                     log(`Promise Result ${index + 1}: Fulfilled. URL: ${result.value.link}, Status: ${result.value.status}, Content starts: ${result.value.content?.substring(0, 50)}...`);
                     return result.value; // The structure from the map function
                 } else {
                     // Log failure details for debugging
                     const reason = result.reason || 'Unknown rejection reason';
                     const errorMessage = reason.message || reason.toString();
                     log(`Promise Result ${index + 1}: Rejected. Reason: ${errorMessage}`);
                     // Try to return a consistent error structure using original info
                     const originalPageInfo = pagesToCrawl[index] || { link: 'unknown', title: 'Unknown Error', snippet: '' };
                      return {
                          ...originalPageInfo,
                          content: `크롤링 실패: ${errorMessage}`, // Provide the error message
                          status: 'rejected' // Explicitly mark as rejected
                      };
                 }
             });
         }



        // --- Google Gemini API Call ---
        // Helper function to escape regex special characters
        function escapeRegExp(string) {
            return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // ** NEW FUNCTION: Generate Follow-up Queries **
        async function generateFollowUpQueries(originalQuestion, initialAnswer) {
            const geminiApiKey = apiKeys?.GEMINI_API_KEY;
            if (!geminiApiKey) {
                throw new Error("Gemini API Key is missing in config.js");
            }
            updateProgress(65, '관련 추가 검색어 생성 중...'); // Progress update
            log('Generating follow-up queries...');

            const prompt = `사용자의 원본 질문과 제공된 초기 답변을 바탕으로, 주제를 더 깊이 탐색하거나 관련된 구체적인 정보를 찾기 위한 관련 검색어 3개를 제안해 주세요. 각 검색어는 5~10단어 내외로 구체적으로 작성하고, 한국어로 생성해야 합니다. 결과는 번호 매기기나 설명 없이 검색어 목록만 제공해 주세요.

원본 질문: ${originalQuestion}

초기 답변 요약 (참고용):
${initialAnswer.substring(0, 500)}...

제안 검색어 목록:`;

            const requestPayload = {
                contents: [{ role: "user", parts: [{ text: prompt }] }],
                safetySettings: [ // Keep safety settings
                  { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ],
                generationConfig: { temperature: 0.7 } // Slightly higher temp for creativity
            };

            const model = "gemini-1.5-flash-latest";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload)
                });
                const data = await response.json();

                if (!response.ok || data.error) {
                    log('Gemini API Error (Follow-up Query Generation):', response.status, response.statusText, JSON.stringify(data));
                    throw new Error(`Gemini API 오류 (추가 검색어 생성): ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }
                 if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                    const feedback = data.promptFeedback || data.candidates?.[0]?.finishReason;
                    log('Gemini No Response or Safety Filter (Follow-up Query Generation):', JSON.stringify(feedback), JSON.stringify(data.candidates?.[0]?.safetyRatings));
                    const reason = data.candidates?.[0]?.finishReason || data.promptFeedback?.blockReason || 'Unknown';
                    // Don't throw an error, just return empty array if generation fails
                    log(`추가 검색어 생성 실패 (이유: ${reason}). 추가 검색 없이 진행합니다.`);
                    return [];
                }

                const generatedText = data.candidates[0].content.parts[0].text;
                // Extract queries (assuming they are line-separated)
                const queries = generatedText.split('\n')
                                             .map(q => q.trim())
                                             .filter(q => q.length > 0); // Remove empty lines

                log('Generated follow-up queries:', queries);
                updateProgress(70, '추가 검색어 생성 완료'); // Progress update
                return queries.slice(0, 3); // Return max 3 queries

            } catch (error) {
                log('Exception during follow-up query generation:', error.message, error.stack);
                // Don't throw, return empty array to allow process to continue
                log('추가 검색어 생성 중 예외 발생. 추가 검색 없이 진행합니다.');
                return [];
            }
        }


        // ** MODIFIED FUNCTION: Get Gemini Response (now handles initial and final calls) **
        async function getGeminiResponse(question, processedResults, isFinalResponse = false, previousAnswer = null) {
            const geminiApiKey = apiKeys?.GEMINI_API_KEY;
            if (!geminiApiKey) {
                throw new Error("Gemini API Key is missing in config.js");
            }

            const progressStart = isFinalResponse ? 85 : 55; // Adjust progress based on stage
            const progressEnd = isFinalResponse ? 100 : 65;
            const statusMsg = isFinalResponse ? '최종 답변 생성 중...' : '초기 답변 생성 중...';

            updateProgress(progressStart, statusMsg);
            log(`Generating ${isFinalResponse ? 'final' : 'initial'} Gemini response...`);

            let context = '';
            const validSourcesForPrompt = [];
            let sourceCounter = 0; // Use a single counter for all sources

             // Function to add results to context and valid list
             const addResultsToContext = (results, prefix = "") => {
                 results.forEach((result) => {
                     sourceCounter++;
                     const sourceNum = sourceCounter;
                     const isFailure = result.content?.startsWith('크롤링 실패') || result.content?.startsWith('크롤링 건너뜀') || result.content?.startsWith('지원하지 않는 콘텐츠 타입') || result.content?.startsWith('[정보 없음]');
                     const isSnippetFallback = result.content?.startsWith('[스니펫 요약]');

                     if ((!isFailure || isSnippetFallback) && result.content && result.content.trim() !== '') {
                         const fullPrefix = prefix ? `${prefix} ` : ""; // Add space if prefix exists
                         log(`Adding to Gemini context (Source ${sourceNum}): ${fullPrefix}${result.title}, Content start: ${result.content.substring(0, 100)}...`);
                         context += `[출처 ${sourceNum}: ${fullPrefix}${result.title}]\n${result.content}\n\n---\n\n`;
                         validSourcesForPrompt.push({...result, sourceNum, originalPrefix: prefix }); // Store original prefix if needed later for display
                     } else {
                         log(`Excluded from Gemini context (Source ${sourceNum}): ${prefix}${result.title}: ${result.content ? 'Content inappropriate/failed: ' + result.content.substring(0,100) + '...' : 'No content'}`);
                         // Optionally add placeholder or skip entirely
                         // context += `[출처 ${sourceNum}: ${prefix}${result.title}] - 정보 없음 또는 분석 실패\n\n---\n\n`;
                         // validSourcesForPrompt.push({...result, sourceNum, originalPrefix: prefix, isExcluded: true }); // Mark as excluded if needed for display list
                     }
                 });
             };

             // Add initial results (always present)
             addResultsToContext(processedResults.initial, "");

             // Add follow-up results if this is the final response and they exist
             if (isFinalResponse && processedResults.followUp && processedResults.followUp.length > 0) {
                 context += "\n\n===== 추가 검색 결과 =====\n\n"; // Separator for clarity in context
                 addResultsToContext(processedResults.followUp, ""); // No prefix needed if using unified numbering
             }


            if (!context) {
                log("Gemini request cancelled: No valid context information available.");
                 updateProgress(progressEnd, '유효 정보 없음');
                return "웹사이트에서 관련 정보를 찾거나 분석할 수 없었습니다. 다른 질문을 시도해 보세요.";
            }

             // Modify system instruction based on whether it's the final response
             const systemInstructionBase = `당신은 제공된 웹 검색 결과(출처)를 바탕으로 사용자 질문에 답변하는 AI 챗봇입니다.
- 각 출처는 '[출처 번호: 제목]' 형식으로 시작합니다.
- 내용을 분석하여 사용자의 질문에 대해 정확하고 상세하게, 한국어로 답변하세요.
- 답변 내용 중 특정 출처를 참고한 부분이 있다면, 해당 문장 끝에 '[출처 번호]' 형식으로 반드시 명시하세요. (예: ... 입니다 [출처 1].)
- 여러 출처를 종합한 경우, 관련된 모든 출처 번호를 명시하세요. (예: ... 입니다 [출처 1][출처 3].)
- 출처 내용만으로 답변하기 어렵거나 정보가 부족하면, "제공된 정보만으로는 답변하기 어렵습니다." 또는 "정보가 부족합니다." 라고 솔직하게 답변하세요. 추측하거나 외부 지식을 사용하지 마세요.`;

             const finalResponseInstruction = isFinalResponse
                 ? "\n- 이것은 최종 답변입니다. 최초 검색 결과와 추가 검색 결과를 모두 종합하여 가장 완전하고 정확한 답변을 생성하세요."
                 : "\n- 이것은 초기 답변입니다. 제공된 정보만을 바탕으로 답변을 생성하세요.";

             const systemInstruction = systemInstructionBase + finalResponseInstruction;

            const requestPayload = {
                contents: [{
                    role: "user",
                    parts: [{ text: `System Instructions:\n${systemInstruction}\n\n---\n\n사용자 질문:\n${question}\n\n---\n\n웹 검색 결과 (참고 자료):\n${context}` }]
                }],
                 safetySettings: [ // Consistent safety settings
                    { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                    { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                 ],
                 generationConfig: { temperature: isFinalResponse ? 0.6 : 0.5 } // Slightly lower temp for initial pass?
             };

            const model = "gemini-2.0-flash-thinking-exp-01-21";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

            log(`Sending ${isFinalResponse ? 'final' : 'initial'} Gemini API request...`);
            // if (DEBUG) { log('Gemini Request Body (Partial):', JSON.stringify(requestPayload).substring(0, 500) + '...'); }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload)
                });
                const data = await response.json();

                if (!response.ok || data.error) {
                    log(`Gemini API Error (${isFinalResponse ? 'Final' : 'Initial'} Response):`, response.status, response.statusText, JSON.stringify(data));
                    throw new Error(`Gemini API 오류 (${isFinalResponse ? '최종' : '초기'} 답변): ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }
                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                     const feedback = data.promptFeedback || data.candidates?.[0]?.finishReason;
                     log(`Gemini No Response or Safety Filter (${isFinalResponse ? 'Final' : 'Initial'} Response):`, JSON.stringify(feedback), JSON.stringify(data.candidates?.[0]?.safetyRatings));
                     const reason = data.candidates?.[0]?.finishReason || data.promptFeedback?.blockReason || 'Unknown';
                     let message = `Gemini가 ${isFinalResponse ? '최종' : '초기'} 응답을 생성하지 못했습니다. 이유: ${reason}.`;
                     if (data.promptFeedback?.safetyRatings) {
                          message += ` (안전 평가: ${data.promptFeedback.safetyRatings.map(r => `${r.category}: ${r.probability}`).join(', ')})`;
                     }
                     // If initial response failed, we might want to stop the process or try fallback
                     if (!isFinalResponse) {
                         log("초기 답변 생성 실패. 프로세스 중단.");
                         // Consider throwing error or returning specific failure object
                         throw new Error("초기 답변 생성 실패: " + reason);
                     }
                      updateProgress(progressEnd, '응답 생성 실패 (필터링)');
                      return message; // Return failure message for final response
                 }


                updateProgress(progressEnd, `${isFinalResponse ? '최종' : '초기'} 응답 생성 완료`);
                log(`Received ${isFinalResponse ? 'final' : 'initial'} Gemini response.`);
                let answer = data.candidates[0].content.parts[0].text;

                // --- Post-processing Gemini Response (Common for both initial and final) ---
                // Link Citations using the unified sourceNum from validSourcesForPrompt
                validSourcesForPrompt.forEach(source => {
                     // Make sure sourceNum exists (it should if added correctly)
                     if (source.sourceNum !== undefined) {
                         const citationRegex = new RegExp(`\\[출처\\s?${source.sourceNum}\\]`, 'g');
                         // Use escapeHtml on link and title for safety
                         const sourceLink = `<a href="${escapeHtml(source.link)}" target="_blank" class="source-link" title="${escapeHtml(source.title)}">[출처 ${source.sourceNum}]</a>`;
                         answer = answer.replace(citationRegex, sourceLink);
                     }
                 });

                // --- REMOVED: Gemini-generated source list linking and title linking ---
                // These are replaced by the final explicit source list appended later.

                // Basic Markdown to HTML (Common)
                answer = answer.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>');
                answer = answer.replace(/\*(.*?)\*/g, '<em>$1</em>');
                answer = answer.replace(/`([^`]+)`/g, '<code>$1</code>');
                answer = answer.replace(/^###+\s+(.*)/gm, '<h5>$1</h5>');
                answer = answer.replace(/^##\s+(.*)/gm, '<h4>$1</h4>');
                answer = answer.replace(/^#\s+(.*)/gm, '<h3>$1</h3>');
                answer = answer.replace(/^\s*[\-\*]\s+(.*)/gm, '<li>$1</li>');
                answer = answer.replace(/(<li>.*<\/li>\s*)+/g, '<ul>$&</ul>'); // Wrap LIs in UL
                 answer = answer.replace(/\n/g, '<br>'); // Convert newlines AFTER list processing
                 // Clean up extra breaks around lists
                 answer = answer.replace(/<\/ul><br>/g, '</ul>');
                 answer = answer.replace(/<br><ul>/g, '<ul>');
                 answer = answer.replace(/<li><br>/g, '<li>');
                 answer = answer.replace(/<br><\/li>/g, '</li>');


                // Return the processed answer (and the valid sources used, if needed for final list)
                return { answer, sources: validSourcesForPrompt };

            } catch (error) {
                log(`Exception during ${isFinalResponse ? 'final' : 'initial'} Gemini response generation/processing:`, error.message, error.stack);
                 updateProgress(progressEnd, '응답 처리 중 오류 발생');
                 // If initial response fails critically, re-throw to stop process
                 if (!isFinalResponse && error.message.includes("초기 답변 생성 실패")) {
                     throw error;
                 }
                 // For final response, return error message
                 return `Gemini ${isFinalResponse ? '최종' : '초기'} 응답 처리 중 오류 발생: ${error.message}`;
            }
        }


        // --- Main Message Processing Orchestrator ---
        async function processMessage(message) {
            addUserMessage(message);
            setLoadingState(true);

            let initialSearchResults = [];
            let initialProcessedResults = [];
            let followUpSearchResults = [];
            let followUpProcessedResults = [];
            let allOriginalSearchResults = []; // To store all results for the final list

            try {
                // ===== STAGE 1: Initial Search & Crawl =====
                updateLoadingMessage('1단계: Google 검색 중...');
                initialSearchResults = await googleSearch(message, 8); // Fetch 8 initial results
                allOriginalSearchResults = [...initialSearchResults]; // Add to the final list
                if (!initialSearchResults || initialSearchResults.length === 0) {
                    addBotMessage('관련 웹페이지를 찾을 수 없습니다. 다른 검색어나 질문을 시도해 보세요.');
                    updateProgress(100, '검색 결과 없음');
                    setLoadingState(false);
                    return;
                }
                log("Initial search results count:", initialSearchResults.length);

                updateLoadingMessage('1단계: 웹페이지 정보 분석 중...');
                const initialPagesToCrawl = initialSearchResults.map(r => ({ link: r.link, title: r.title, snippet: r.snippet }));
                // Allocate progress: Search (0-10), Crawl (10-50), Initial Gemini (50-65)
                initialProcessedResults = await crawlWebpages(initialPagesToCrawl, 10, 50);
                log("Initial crawl results count:", initialProcessedResults.length);

                // Apply Snippet Fallback for initial results
                initialProcessedResults = initialProcessedResults.map(result => {
                    const crawlFailed = result.status === 'rejected' || result.content?.startsWith('크롤링 실패') || result.content?.startsWith('크롤링 건너뜀') || result.content?.startsWith('지원하지 않는 콘텐츠 타입');
                    const hasSnippet = result.snippet && result.snippet.trim() !== '';
                    if (crawlFailed && hasSnippet) {
                        log(`Using snippet for initial result: ${result.title}`);
                        return { ...result, content: `[스니펫 요약] ${result.snippet}`, status: 'fulfilled_with_snippet' };
                    } else if (crawlFailed) {
                        log(`No snippet for failed initial crawl: ${result.title}`);
                        return { ...result, content: `[정보 없음] ${result.content || '크롤링 실패'}`, status: 'rejected_no_snippet' };
                    }
                    return { ...result, status: 'fulfilled' }; // Mark successful crawls explicitly
                });


                // ===== STAGE 2: Generate Initial Gemini Response (Internal Only) =====
                updateLoadingMessage('2단계: 초기 답변 생성 중 (내부)...');
                // Prepare data structure for getGeminiResponse
                const initialDataForGemini = { initial: initialProcessedResults };
                const initialGeminiResult = await getGeminiResponse(message, initialDataForGemini, false);

                // Check if the result is an error string or the expected object
                if (typeof initialGeminiResult === 'string') {
                    // Handle error message from getGeminiResponse
                     log("초기 답변 생성 실패:", initialGeminiResult);
                     addBotMessage(initialGeminiResult); // Show the error
                     updateProgress(100, '초기 답변 생성 오류');
                     setLoadingState(false);
                     return;
                 }
                 if (!initialGeminiResult || !initialGeminiResult.answer) {
                      log("초기 답변 생성 실패: 유효하지 않은 응답 객체");
                      addBotMessage("초기 답변 생성 중 문제가 발생했습니다.");
                      updateProgress(100, '초기 답변 생성 오류');
                      setLoadingState(false);
                      return;
                 }

                 const initialAnswerText = initialGeminiResult.answer; // Use the answer text
                 log("Initial Gemini response generated internally.");
                 // ** DO NOT DISPLAY initialAnswerText to the user **


                // ===== STAGE 3: Generate Follow-up Queries =====
                updateLoadingMessage('3단계: 추가 검색어 생성 중...');
                const followUpQueries = await generateFollowUpQueries(message, initialAnswerText);

                if (!followUpQueries || followUpQueries.length === 0) {
                    log("No follow-up queries generated or generation failed. Proceeding without additional search.");
                    // Skip stage 4 and go directly to final response generation with initial data only
                } else {
                    // ===== STAGE 4: Follow-up Search & Crawl =====
                    updateLoadingMessage(`4단계: 추가 정보 검색 중 (${followUpQueries.length}개)...`);
                    let followUpSearchPromises = followUpQueries.map(query => googleSearch(query, 3)); // Fetch 3 results per query
                    const followUpSearchResultsNested = await Promise.all(followUpSearchPromises);
                    followUpSearchResults = followUpSearchResultsNested.flat(); // Flatten the array of arrays
                    allOriginalSearchResults.push(...followUpSearchResults); // Add to the final list

                    log("Follow-up search results count:", followUpSearchResults.length);

                    if (followUpSearchResults.length > 0) {
                        updateLoadingMessage('4단계: 추가 웹페이지 분석 중...');
                        const followUpPagesToCrawl = followUpSearchResults.map(r => ({ link: r.link, title: r.title, snippet: r.snippet }));
                         // Allocate progress: Follow-up Query (65-70), Follow-up Search/Crawl (70-85), Final Gemini (85-100)
                         followUpProcessedResults = await crawlWebpages(followUpPagesToCrawl, 70, 85);
                         log("Follow-up crawl results count:", followUpProcessedResults.length);

                         // Apply Snippet Fallback for follow-up results
                         followUpProcessedResults = followUpProcessedResults.map(result => {
                             const crawlFailed = result.status === 'rejected' || result.content?.startsWith('크롤링 실패') || result.content?.startsWith('크롤링 건너뜀') || result.content?.startsWith('지원하지 않는 콘텐츠 타입');
                             const hasSnippet = result.snippet && result.snippet.trim() !== '';
                             if (crawlFailed && hasSnippet) {
                                 log(`Using snippet for follow-up result: ${result.title}`);
                                 return { ...result, content: `[스니펫 요약] ${result.snippet}`, status: 'fulfilled_with_snippet' };
                             } else if (crawlFailed) {
                                 log(`No snippet for failed follow-up crawl: ${result.title}`);
                                 return { ...result, content: `[정보 없음] ${result.content || '크롤링 실패'}`, status: 'rejected_no_snippet' };
                             }
                             return { ...result, status: 'fulfilled' };
                         });
                     } else {
                         log("추가 검색 결과 없음.");
                         followUpProcessedResults = []; // Ensure it's an empty array
                         updateProgress(85, '추가 검색 결과 없음'); // Skip crawl progress if no search results
                     }
                 }

                // ===== STAGE 5: Generate Final Gemini Response =====
                updateLoadingMessage('5단계: 최종 답변 생성 중...');
                // Prepare combined data for the final response generation
                const finalDataForGemini = {
                    initial: initialProcessedResults,
                    followUp: followUpProcessedResults // Pass follow-up results (could be empty)
                };
                const finalGeminiResult = await getGeminiResponse(message, finalDataForGemini, true, initialAnswerText); // Pass isFinalResponse=true

                // Check for errors in final response generation
                 if (typeof finalGeminiResult === 'string') {
                      log("최종 답변 생성 실패:", finalGeminiResult);
                      addBotMessage(finalGeminiResult); // Show the error
                      updateProgress(100, '최종 답변 생성 오류');
                      setLoadingState(false);
                      return;
                  }
                  if (!finalGeminiResult || !finalGeminiResult.answer) {
                       log("최종 답변 생성 실패: 유효하지 않은 응답 객체");
                       addBotMessage("최종 답변 생성 중 문제가 발생했습니다.");
                       updateProgress(100, '최종 답변 생성 오류');
                       setLoadingState(false);
                       return;
                  }


                 const finalAnswerHtml = finalGeminiResult.answer;
                 removeLoadingMessage(); // Remove loading indicator *before* adding final message
                 const botMsgElement = addBotMessage(finalAnswerHtml, true); // Display final answer (HTML formatted)


                // ===== STAGE 6: Append Combined Original Search Results List =====
                if (botMsgElement && allOriginalSearchResults.length > 0) {
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.className = 'mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 no-print';

                    // Create the combined list HTML
                    let sourcesHtml = '<p class="font-medium mb-2">참고한 원본 검색 결과 (1차 및 2차 포함):</p><ul class="list-disc list-inside space-y-1">';
                     // Use a Set to prevent duplicate links in the final list
                     const uniqueLinks = new Set();
                     allOriginalSearchResults.forEach((result, index) => {
                         if (result && result.link && !uniqueLinks.has(result.link)) {
                              uniqueLinks.add(result.link);
                              sourcesHtml += `<li><a href="${escapeHtml(result.link)}" target="_blank" class="source-link hover:underline" title="${escapeHtml(result.snippet)}">${escapeHtml(result.title)}</a></li>`;
                         }
                     });
                    sourcesHtml += '</ul>';
                    sourcesDiv.innerHTML = sourcesHtml;

                    botMsgElement.appendChild(sourcesDiv);
                    scrollToBottom(); // Scroll after adding the final element
                }

            } catch (error) {
                // Catch errors from any stage (search, crawl, Gemini calls)
                log('전체 처리 과정 중 오류 발생:', error.message, error.stack);
                removeLoadingMessage(); // Ensure loading message is removed on error
                addBotMessage(`처리 중 오류가 발생했습니다: ${error.message}`);
                updateProgress(100, '오류 발생'); // Set progress to 100% to hide the bar
            } finally {
                setLoadingState(false); // Ensure UI is re-enabled
                 // Make sure progress bar hides if not already hidden by 100% completion
                 if (!progressSection.classList.contains('hidden') && progressBar.style.width !== '100%') {
                      setTimeout(() => updateProgress(100, progressStatus.textContent || '완료'), 200); // Force hide after slight delay
                 }
            }
        }


        // --- Event Listeners ---
        // (이벤트 리스너 코드는 변경 없음 - 생략)
        sendButton.addEventListener('click', () => {
            const message = userInput.value.trim();
            if (message && !sendButton.disabled) { // Check if not disabled
                userInput.value = '';
                userInput.focus(); // Keep focus on input
                processMessage(message);
            }
        });

        userInput.addEventListener('keypress', (e) => {
            // Send on Enter key press (if not disabled)
            if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) {
                e.preventDefault(); // Prevent default form submission/newline
                sendButton.click();
            }
        });


        // --- Initialization ---
        log("챗봇 초기화 완료. 2단계 검색 및 답변 생성 로직 적용됨."); // Updated log message
        userInput.focus();

    </script>
</body>
</html>
