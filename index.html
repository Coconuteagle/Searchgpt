<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>검색 기반 Gemini 챗봇 (Matrix Style)</title>

  <!-- Tailwind / FontAwesome -->
  <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">

  <!-- 반드시 config.js가 먼저 로드되어야 한다! -->
  <script src="config.js"></script>

  <style>
    /* ------------------- 전체 매트릭스 테마 (검은 배경, 초록 텍스트, 모노스페이스) ------------------- */
    body {
      background-color: #000000 !important;
      color: #00ff00 !important;
      font-family: Consolas, 'Courier New', monospace;
      margin: 0;
      padding: 0;
    }

    /* 링크, 버튼 등도 초록색으로 */
    a, button {
      color: #00ff00 !important;
    }
    a:hover, button:hover {
      opacity: 0.8;
    }
    /* Tailwind 배경색, 테두리 등도 전부 덮어쓰기 */
    .bg-white, .dark\\:bg-gray-800, .bg-gray-50, .container, .bg-gray-100, .rounded-lg {
      background-color: #000000 !important;
      border: 1px solid #008f11 !important;
    }
    .border-gray-200, .border-gray-700 {
      border-color: #008f11 !important;
    }
    /* 일반 텍스트(회색->초록) */
    .text-gray-800, .dark\\:text-gray-200,
    .text-gray-600, .dark\\:text-gray-400,
    .text-gray-500, .dark\\:text-gray-300 {
      color: #00ff00 !important;
    }
    /* ------------------- 채팅 영역 ------------------- */
    .chat-container {
      height: calc(100vh - 180px);
      min-height: 400px;
      overflow-y: auto;
      padding-right: 4px; /* 스크롤바 대비 여백 */
    }
    .user-message {
      background-color: #002200;
      border: 1px solid #00ff00;
      border-radius: 18px 18px 2px 18px;
      margin-left: auto;
      margin-right: 0;
      color: #00ff00;
    }
    .bot-message {
      background-color: #001100;
      border: 1px solid #00ff00;
      border-radius: 18px 18px 18px 2px;
      margin-left: 0;
      margin-right: auto;
      color: #00ff00;
    }

    /* 버튼, 인풋 등도 어둡고 초록 테두리 */
    .matrix-input {
      background-color: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
    }
    .matrix-button {
      background-color: #000;
      border: 1px solid #00ff00;
      color: #00ff00;
      transition: opacity 0.2s;
    }
    .matrix-button:hover {
      opacity: 0.8;
    }
    .matrix-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* ------------------- 처리 단계(Status) UI ------------------- */
    #status-list-container {
      border: 1px solid #008f11;
      padding: 8px;
      margin-bottom: 8px;
    }
    .status-item {
      display: flex;
      align-items: center;
      transition: all 0.3s ease;
      padding: 0.25rem 0;
      color: #00ff00;
      font-size: 0.9rem;
    }
    .status-icon {
      width: 20px;
      text-align: center;
      margin-right: 0.5rem;
      transition: color 0.3s ease;
    }
    .status-label {
      transition: color 0.3s ease, text-decoration 0.3s ease;
    }
    .status-detail {
      margin-left: 0.5rem;
      font-size: 0.8rem;
      color: #00ff00;
    }
    .status-item.status-pending .status-icon {
      color: #008f11;
    }
    .status-item.status-pending .status-label {
      color: #008f11;
    }
    .status-item.status-pending .status-detail {
      display: none;
    }
    .status-item.status-active .status-icon {
      color: #00ff00;
      animation: spin 1s linear infinite;
    }
    .status-item.status-active .status-label {
      font-weight: 600;
    }
    .status-item.status-active .status-detail {
      display: inline;
    }
    .status-item.status-completed .status-icon {
      color: #00ff00;
      animation: none;
    }
    .status-item.status-completed .status-label {
      color: #008f11;
      text-decoration: line-through;
    }
    .status-item.status-completed .status-detail {
      display: none;
    }
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* 링크 스타일 */
    .source-link {
      color: #00ff00;
      text-decoration: underline;
      word-break: break-all;
    }
    .source-link:hover {
      text-decoration: none;
      opacity: 0.9;
    }

    /* 인쇄 스타일 */
    @media print {
      .no-print {
        display: none !important;
      }
      body {
        background-color: #fff !important;
        color: #000 !important;
        font-family: sans-serif !important;
      }
      .chat-container {
        height: auto;
        max-height: none;
        overflow: visible;
      }
      .user-message, .bot-message {
        background-color: #f1f1f1 !important;
        color: #000 !important;
        border: 1px solid #ddd !important;
      }
      .source-link {
        color: #0000EE !important;
        text-decoration: underline !important;
      }
      .print-break {
        page-break-before: always;
      }
      #chat-form {
        display: none !important;
      }
      #status-list-container {
        display: none !important;
      }
    }
  </style>
</head>

<body>
<div class="container mx-auto px-4 py-8 max-w-6xl">
  <!-- 상단 영역 -->
  <div class="flex justify-between items-center mb-6 no-print">
    <h1 class="text-3xl font-bold">
      검색 기반 Gemini 챗봇 (Matrix Style)
    </h1>
    <button onclick="window.print()"
            class="matrix-button px-3 py-2 rounded-md focus:outline-none">
      <i class="fas fa-print"></i> 인쇄
    </button>
  </div>

  <!-- 채팅 전체 박스 -->
  <div id="chat-box"
       class="bg-black rounded-lg shadow-lg overflow-hidden"
       style="border: 1px solid #008f11;">

    <!-- 채팅 메시지 + (처리과정 표시 UI가 들어갈) 영역 -->
    <div id="chat-messages" class="chat-container p-4 space-y-4">
      <!-- 초기 안내 메시지 -->
      <div class="bot-message p-4">
        안녕하세요! 검색 기반 Gemini 챗봇입니다. 궁금한 점이 있으시면 질문해 주세요.
      </div>
    </div>

    <!-- 입력 폼 -->
    <div id="chat-form" class="p-4 border-t border-gray-200 no-print">
      <div class="max-w-3xl mx-auto">
        <div class="flex space-x-2">
          <input type="text" id="user-input"
                 class="matrix-input flex-grow px-4 py-2 rounded-l-md shadow-sm focus:outline-none"
                 placeholder="질문을 입력하세요...">
          <button id="send-button"
                  class="matrix-button px-4 py-2 rounded-r-md focus:outline-none disabled:opacity-50"
                  aria-label="Send message">
            <i class="fas fa-paper-plane"></i>
          </button>
        </div>
      </div>
    </div>

  </div>

  <!-- 하단 영역 -->
  <div class="mt-6 text-center no-print">
    <p>© 2025 검색 기반 Gemini 챗봇 by 수현</p>
  </div>
</div>

<script>
    // --- Basic Setup ---
    const DEBUG = true;
    function log(...args) {
        if (DEBUG) {
            console.log(`[챗봇 로그 ${new Date().toLocaleTimeString()}]`, ...args);
        }
    }

    // [CHANGED] 여러 개의 Google Search Key/ID가 config.js의 apiKeys.GOOGLE_SEARCH_CONFIGS에 있다고 가정.
    const googleSearchConfigs = (window.apiKeys && Array.isArray(window.apiKeys.GOOGLE_SEARCH_CONFIGS))
        ? window.apiKeys.GOOGLE_SEARCH_CONFIGS
        : [];

    // 현재 사용중인 search config 인덱스
    let currentSearchConfigIndex = 0;

    // Gemini API Key 역시 config.js에서 가져옴
    const geminiApiKey = window.apiKeys?.GEMINI_API_KEY;

    // 필수 체크
    if (!geminiApiKey) {
        console.error("Gemini API Key가 config.js에서 주어지지 않았습니다. (apiKeys.GEMINI_API_KEY)");
        alert("Gemini API Key가 설정되지 않았습니다. config.js 파일을 확인하세요.");
    }
    if (!googleSearchConfigs.length) {
        console.error("Google Search API Key/엔진 ID 세트가 하나도 설정되지 않았습니다. (apiKeys.GOOGLE_SEARCH_CONFIGS)");
        alert("검색 API 키/엔진 ID 정보가 없습니다. config.js 파일을 확인하세요.");
    }

    // --- DOM Elements ---
    const chatMessages = document.getElementById('chat-messages');
    const userInput = document.getElementById('user-input');
    const sendButton = document.getElementById('send-button');
    const chatForm = document.getElementById('chat-form');

    // --- Cache System ---
    const cache = {
        search: new Map(),
        crawl: new Map(),
        maxAge: 30 * 60 * 1000, // 30분
        getSearch(query) {
            const item = this.search.get(query);
            if (item && (Date.now() - item.timestamp < this.maxAge)) {
                log('Search cache hit:', query);
                return item.data;
            }
            log('Search cache miss:', query);
            return null;
        },
        setSearch(query, data) {
            this.search.set(query, { data, timestamp: Date.now() });
            log('Search cache set:', query);
        },
        getCrawl(url) {
            const item = this.crawl.get(url);
            if (item && (Date.now() - item.timestamp < this.maxAge)) {
                log('Crawl cache hit:', url);
                return item.data;
            }
            log('Crawl cache miss:', url);
            return null;
        },
        setCrawl(url, data) {
            this.crawl.set(url, { data, timestamp: Date.now() });
            log('Crawl cache set:', url, 'Length:', data?.length);
        }
    };

    // --- UI Update Functions ---
    function escapeHtml(unsafe) {
        if (unsafe === null || typeof unsafe === 'undefined') return '';
        return unsafe
            .toString()
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#039;");
    }

    function addUserMessage(message) {
        const messageDiv = document.createElement('div');
        messageDiv.className = 'user-message p-3 md:p-4 max-w-3xl ml-auto mb-4';
        messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
        chatMessages.appendChild(messageDiv);
        scrollToBottom();
    }

    function addBotMessage(message, isHTML = false) {
        removeStatusUI(); // 상태 UI 제거(최종 메시지 출력 시)

        const messageDiv = document.createElement('div');
        messageDiv.className = 'bot-message p-3 md:p-4 max-w-3xl mr-auto mb-4';

        if (isHTML) {
            // 스크립트 태그 제거
            const sanitizedHTML = message.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, '');
            messageDiv.innerHTML = sanitizedHTML;
        } else {
            messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
        }

        chatMessages.appendChild(messageDiv);
        scrollToBottom();
        return messageDiv;
    }

    function scrollToBottom() {
        setTimeout(() => {
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }, 50);
    }

    // --- NEW Status UI Functions ---
    const statusSteps = [
        { id: 1, label: "1단계: 초기 정보 검색" },
        { id: 2, label: "2단계: 초기 정보 분석" },
        { id: 3, label: "3단계: 추가 탐색 준비" },
        { id: 4, label: "4단계: 추가 정보 검색 및 분석" },
        { id: 5, label: "5단계: 종합하여 생각 중" }
    ];

    function createStatusUI() {
        removeStatusUI();

        const container = document.createElement('div');
        container.id = 'status-list-container';
        container.className = 'mb-3';

        const list = document.createElement('ul');
        list.id = 'status-list';
        list.className = 'space-y-1';

        statusSteps.forEach(step => {
            const item = document.createElement('li');
            item.className = 'status-item status-pending';
            item.dataset.step = step.id;
            item.innerHTML = `
                <span class="status-icon"><i class="far fa-circle"></i></span>
                <span class="status-label">${escapeHtml(step.label)}</span>
                <span class="status-detail ml-2"></span>
            `;
            list.appendChild(item);
        });

        container.appendChild(list);

        // 처리 과정 표시 영역을 "채팅창(답변 출력) 내부"에 삽입
        chatMessages.appendChild(container);
        scrollToBottom();
    }

    function updateStatusUI(step, status, detailText = '') {
        const container = document.getElementById('status-list-container');
        if (!container) return;

        const item = container.querySelector(`li[data-step="${step}"]`);
        if (!item) return;

        item.classList.remove('status-pending', 'status-active', 'status-completed');
        item.classList.add(`status-${status}`);

        const icon = item.querySelector('.status-icon i');
        if (icon) {
            if (status === 'active') {
                icon.className = 'fas fa-spinner fa-spin';
            } else if (status === 'completed') {
                icon.className = 'fas fa-check-circle';
            } else {
                icon.className = 'far fa-circle';
            }
        }

        const detail = item.querySelector('.status-detail');
        if (detail) {
            detail.textContent = detailText;
            detail.style.display = (status === 'active' && detailText) ? 'inline' : 'none';
        }

        // 이전 단계들 자동 완료 처리
        if (status === 'active' || status === 'completed') {
            for (let i = 1; i < step; i++) {
                const prevItem = container.querySelector(`li[data-step="${i}"]`);
                if (prevItem && !prevItem.classList.contains('status-completed')) {
                    prevItem.classList.remove('status-pending', 'status-active');
                    prevItem.classList.add('status-completed');
                    const prevIcon = prevItem.querySelector('.status-icon i');
                    if (prevIcon) prevIcon.className = 'fas fa-check-circle';
                    const prevDetail = prevItem.querySelector('.status-detail');
                    if (prevDetail) prevDetail.style.display = 'none';
                }
            }
        }
        scrollToBottom();
    }

    function removeStatusUI() {
        const container = document.getElementById('status-list-container');
        if (container) {
            container.remove();
        }
    }

    function setLoadingState(isLoading) {
        if (isLoading) {
            sendButton.disabled = true;
            userInput.disabled = true;
            createStatusUI();
        } else {
            sendButton.disabled = false;
            userInput.disabled = false;
            // 최종 봇메시지 추가 시 removeStatusUI() 별도 호출
        }
    }

    // --- Web Crawling 관련 로직 ---
    const PROXY_COOLDOWN_MS = 3 * 60 * 1000;
    const proxies = [
        { name: 'corsproxy.io', url: (targetUrl) => `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`, cooldownUntil: 0 },
        { name: 'allorigins',  url: (targetUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`, cooldownUntil: 0 },
    ];

    async function crawlWebpage(url, attempt = 0) {
        const cachedContent = cache.getCrawl(url);
        if (cachedContent) {
            return cachedContent;
        }

        const availableProxies = proxies.filter(p => Date.now() >= (p.cooldownUntil || 0));
        if (availableProxies.length === 0) {
            const soonestAvailable = proxies.reduce((soonest, p) => ((p.cooldownUntil || 0) < (soonest.cooldownUntil || 0) ? p : soonest), proxies[0]);
            const waitTime = soonestAvailable ? Math.ceil(((soonestAvailable.cooldownUntil || 0) - Date.now()) / 1000) : 'N/A';
            log(`Crawl failed: All proxies on cooldown. URL: ${url}. Next available in ~${waitTime}s`);
            return `크롤링 실패 (모든 프록시 쿨다운 중, 약 ${waitTime}초 후 재시도 가능): ${url}`;
        }

        const maxRetriesForUrl = availableProxies.length;
        if (attempt >= maxRetriesForUrl) {
            log(`Crawl max retries reached (${maxRetriesForUrl}) for URL: ${url}`);
            return `크롤링 실패 (최대 재시도): ${url}`;
        }

        const proxy = availableProxies[attempt];
        log(`[${proxy.name}] Crawl attempt ${attempt + 1}/${maxRetriesForUrl}: ${url}`);

        try {
            if (!url || !url.startsWith('http')) {
                log(`[${proxy.name}] Skipping crawl (Invalid URL): ${url}`);
                throw new Error(`유효하지 않은 URL: ${url}`);
            }
            const path = url.split('?')[0];
            const fileExtension = path.includes('.') ? path.split('.').pop().toLowerCase() : '';
            const nonHtmlExtensions = [
                'pdf','doc','docx','ppt','pptx','xls','xlsx','zip','rar','jpg','jpeg','png','gif','webp','svg','mp3','mp4','avi','mov','exe','dmg'
            ];
            if (nonHtmlExtensions.includes(fileExtension)) {
                log(`[${proxy.name}] Skipping crawl (File type ${fileExtension}): ${url}`);
                return `크롤링 건너뜀 (파일 형식 ${fileExtension.toUpperCase()}): ${url}`;
            }

            const controller = new AbortController();
            const timeoutId = setTimeout(() => {
                controller.abort();
                log(`[${proxy.name}] Timeout (15s) occurred for URL: ${url}`);
            }, 15000);

            const proxyUrl = proxy.url(url);
            const headers = {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64)',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
                'Upgrade-Insecure-Requests': '1',
                'Sec-Fetch-Dest': 'document',
                'Sec-Fetch-Mode': 'navigate',
                'Sec-Fetch-Site': 'cross-site',
            };

            const response = await fetch(proxyUrl, {
                signal: controller.signal,
                headers: headers,
                mode: 'cors',
                referrerPolicy: 'strict-origin-when-cross-origin'
            });
            clearTimeout(timeoutId);

            if (!response.ok) {
                let errorBody = '';
                try { errorBody = await response.text(); } catch (_) {}
                log(`[${proxy.name}] HTTP Error ${response.status} (${response.statusText}). URL: ${url}. Snippet: ${errorBody.substring(0, 200)}...`);
                throw new Error(`HTTP 오류 ${response.status}`);
            }

            const contentType = response.headers.get('content-type') || '';
            log(`[${proxy.name}] Response Content-Type: ${contentType}. URL: ${url}`);
            if (!contentType.includes('text/html')
                && !contentType.includes('application/xhtml+xml')
                && !contentType.includes('text/plain')) {

                if (contentType.includes('application/json')) {
                    try {
                        const json = await response.json();
                        const textContent = `JSON 데이터:\n${JSON.stringify(json, null, 2)}`.substring(0, 8000);
                        cache.setCrawl(url, textContent);
                        log(`[${proxy.name}] JSON data processed successfully. URL: ${url}`);
                        return textContent;
                    } catch (e) {
                        log(`[${proxy.name}] JSON parsing error:`, e);
                        return `JSON 파싱 오류. Content-Type: ${contentType}, URL: ${url}`;
                    }
                } else if (contentType.includes('xml') && !contentType.includes('xhtml')) {
                    try {
                        const xmlText = await response.text();
                        const textContent = `XML 데이터:\n${xmlText}`.substring(0, 8000);
                        cache.setCrawl(url, textContent);
                        log(`[${proxy.name}] XML data processed. URL: ${url}`);
                        return textContent;
                    } catch(e) {
                        log(`[${proxy.name}] XML parsing error:`, e);
                        return `XML 파싱 오류. Content-Type: ${contentType}, URL: ${url}`;
                    }
                }
                log(`[${proxy.name}] Unsupported Content-Type: ${contentType}, URL: ${url}`);
                return `지원하지 않는 콘텐츠 타입 (${contentType}): ${url}`;
            }

            const html = await response.text();
            if (!html || html.trim().length === 0) {
                log(`[${proxy.name}] Empty response content. URL: ${url}`);
                throw new Error('빈 응답 또는 내용 없음');
            }

            const parser = new DOMParser();
            const doc = parser.parseFromString(html, 'text/html');
            const title = doc.querySelector('title')?.textContent.trim() || url;
            const metaDescription = doc.querySelector('meta[name="description"]')?.getAttribute('content')?.trim() || '';

            const elementsToRemove = [
                'script','style','svg','img','picture','video','audio','iframe','nav','header','footer','aside','form',
                'noscript','button','input','select','textarea','label','canvas','map','object','embed','.advertisement',
                '.ad','#ad','.banner','.popup','.modal','.sidebar','.social-links','.share-buttons','.cookie-consent',
                '[aria-hidden="true"]'
            ];
            elementsToRemove.forEach(selector => {
                try {
                    doc.querySelectorAll(selector).forEach(el => el.remove());
                } catch (e) {
                    log(`[${proxy.name}] CSS Selector Error:`, selector, e);
                }
            });

            let mainContent = doc.querySelector('main')
                || doc.querySelector('article')
                || doc.querySelector('[role="main"]')
                || doc.querySelector('.content, .main-content, .post-content, .entry-content, #content, #main, .article-body, .entry, .page-content');

            if (!mainContent || mainContent.textContent.trim().length < 100) {
                log(`[${proxy.name}] Main content missing or too short, fallback to body. URL: ${url}`);
                mainContent = doc.body;
            }

            let text = '';
            const significantTags = ['p','h1','h2','h3','h4','h5','h6','li','blockquote','pre','div','td'];

            function extractTextNodes(node) {
                let nodeText = '';
                if (!node) return '';

                for (const child of node.childNodes) {
                    if (child.nodeType === Node.TEXT_NODE) {
                        nodeText += child.textContent;
                    } else if (child.nodeType === Node.ELEMENT_NODE) {
                        const tagName = child.tagName.toLowerCase();
                        let displayStyle = 'inline';
                        try {
                            displayStyle = window.getComputedStyle(child).display;
                        } catch(e) {
                            if (['p','h1','h2','h3','h4','h5','h6','li','blockquote','pre','div','td','tr','ul','ol','section','article','aside','nav','header','footer'].includes(tagName)) {
                                displayStyle = 'block';
                            }
                        }
                        if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && text.length > 0 && !text.endsWith('\n')) {
                            nodeText += '\n';
                        }
                        nodeText += extractTextNodes(child);
                        if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && !nodeText.endsWith('\n')) {
                            nodeText += '\n';
                        }
                    }
                }
                return nodeText;
            }

            text = extractTextNodes(mainContent);
            text = text.replace(/(\s*\n\s*){3,}/g, '\n\n')
                       .replace(/[ \t]{2,}/g, ' ')
                       .replace(/^\s+|\s+$/gm, '')
                       .trim();
            text = `제목: ${title}\n${metaDescription ? '설명: ' + metaDescription + '\n' : ''}\n---\n\n${text}`;

            const maxLength = 8000;
            if (text.length > maxLength) {
                text = text.substring(0, maxLength) + '... [내용 중략됨]';
                log(`[${proxy.name}] Truncated content to ${maxLength} chars. URL: ${url}`);
            }

            cache.setCrawl(url, text);
            return text;

        } catch (error) {
            log(`[${proxy.name}] Exception on attempt ${attempt+1}/${maxRetriesForUrl}:`, error);
            proxy.cooldownUntil = Date.now() + PROXY_COOLDOWN_MS;
            return crawlWebpage(url, attempt + 1);
        }
    }

    async function crawlWebpages(pagesToCrawl, currentStep) {
        const totalSites = pagesToCrawl.length;
        if (totalSites === 0) return [];

        log(`Starting crawl/analysis for ${totalSites} sites (Step ${currentStep}).`);
        updateStatusUI(currentStep, 'active', `웹페이지 분석 시작 (0/${totalSites})...`);

        let completedCount = 0;
        const crawlPromises = pagesToCrawl.map(async (pageInfo) => {
            try {
                const content = await crawlWebpage(pageInfo.link);
                completedCount++;
                updateStatusUI(currentStep, 'active', `${totalSites}개 중 ${completedCount}개 사이트 분석 완료`);
                return { ...pageInfo, content: content || '[내용 없음]', status: 'fulfilled' };
            } catch (error) {
                completedCount++;
                updateStatusUI(currentStep, 'active', `${totalSites}개 중 ${completedCount}개 사이트 분석 완료 (오류 포함)`);
                return { ...pageInfo, content: `크롤링 중 오류: ${error.message}`, status: 'rejected' };
            }
        });

        const results = await Promise.allSettled(crawlPromises);
        updateStatusUI(currentStep, 'active', '분석 완료');

        return results.map((result, idx) => {
            if (result.status === 'fulfilled') {
                return result.value;
            } else {
                const originalPageInfo = pagesToCrawl[idx];
                const msg = result.reason ? result.reason.message || String(result.reason) : "알 수 없는 오류";
                return { ...originalPageInfo, content: `크롤링 실패: ${msg}`, status: 'rejected' };
            }
        });
    }

    // [CHANGED] 여러 Search Config을 순차적으로 시도
    async function googleSearch(query, numResults = 8, attempt = 0) {
        // 모두 소진했을 경우
        if (currentSearchConfigIndex >= googleSearchConfigs.length) {
            throw new Error("Google 검색 API 오류: 모든 키/엔진 세트가 한도 초과되었습니다.");
        }

        // 캐시
        const cachedResults = cache.getSearch(query);
        if (cachedResults) {
            log('Search cache hit:', query);
            return cachedResults;
        }

        const { googleApiKey, searchEngineId } = googleSearchConfigs[currentSearchConfigIndex];
        if (!googleApiKey || !searchEngineId) {
            throw new Error(`Google Search API Key/Engine ID가 유효하지 않습니다 (인덱스: ${currentSearchConfigIndex}).`);
        }

        try {
            const apiUrl = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&num=${numResults}`;
            log("Google Search API Request:", apiUrl);

            const response = await fetch(apiUrl);
            const data = await response.json();

            if (!response.ok || data.error) {
                const errorMessage = data.error ? data.error.message : `HTTP ${response.status}`;
                log("Google Search API Error:", errorMessage);
                // quota exceeded라면 다음으로 스위치
                if (errorMessage.includes("Quota exceeded") || errorMessage.includes("limit")
                    || response.status === 403) {
                    log(`Switching to next Google Search config. Index was ${currentSearchConfigIndex}.`);
                    currentSearchConfigIndex++;
                    return googleSearch(query, numResults, attempt + 1);
                }
                throw new Error(`Google 검색 API 오류: ${errorMessage}`);
            }

            if (!data.items || data.items.length === 0) {
                log(`No results for query: ${query}`);
                cache.setSearch(query, []);
                return [];
            }

            const results = data.items.map(item => ({
                title: item.title,
                link: item.link,
                snippet: item.snippet
            }));
            cache.setSearch(query, results);
            return results;

        } catch (error) {
            log("Google Search 예외:", error.message);
            // Quota exceeded 추정 시
            if (error.message.includes("Quota exceeded") || error.message.includes("limit") || error.message.includes("403")) {
                currentSearchConfigIndex++;
                return googleSearch(query, numResults, attempt + 1);
            }
            throw error;
        }
    }

    // Gemini API
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    async function generateFollowUpQueries(originalQuestion, initialAnswer) {
        if (!geminiApiKey) {
            throw new Error("Gemini API Key가 없습니다.");
        }
        updateStatusUI(3, 'active', '초기 답변 기반 추가 탐색 준비 중...');
        log('Generating follow-up queries...');

        const prompt = `사용자의 원본 질문과 제공된 초기 답변을 바탕으로, 주제를 더 깊이 탐색하거나 관련된 구체적인 정보를 찾기 위한 관련 검색어 3개를 제안해 주세요. 각 검색어는 5~10단어 내외로 구체적으로 작성하고, 한국어로 생성해야 합니다. 결과는 번호 매기기나 설명 없이 검색어 목록만 제공해 주세요.

원본 질문: ${originalQuestion}

초기 답변 요약 (참고용):
${initialAnswer.substring(0, 500)}...

제안 검색어 목록:`;

        const requestPayload = {
            contents: [{ role: "user", parts: [{ text: prompt }] }],
            safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
            ],
            generationConfig: { temperature: 0.7 }
        };

        const model = "gemini-1.5-flash-latest";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestPayload)
            });
            const data = await response.json();

            if (!response.ok || data.error) {
                throw new Error(`Gemini API 오류 (추가 검색어 생성): ${data.error ? data.error.message : `HTTP ${response.status}`}`);
            }
            if (!data.candidates || !data.candidates[0].content) {
                log('No follow-up queries generated or blocked by safety filter.');
                updateStatusUI(3, 'active', '추가 검색어 생성 실패');
                return [];
            }

            const generatedText = data.candidates[0].content.parts[0].text;
            const queries = generatedText.split('\n').map(q => q.trim()).filter(q => q);
            log('Generated follow-up queries:', queries);

            updateStatusUI(3, 'active', '추가 검색어 생성 완료');
            return queries.slice(0, 3);

        } catch (error) {
            log('Follow-up query generation error:', error);
            updateStatusUI(3, 'active', '추가 검색어 생성 중 오류');
            return [];
        }
    }

    async function getGeminiResponse(question, processedResults, isFinalResponse = false, previousAnswer = null) {
        if (!geminiApiKey) {
            throw new Error("Gemini API Key가 없습니다.");
        }
        const currentStep = isFinalResponse ? 5 : 3;
        const statusMsg = isFinalResponse ? '종합하여 생각 중...' : '초기 분석 기반 생각 중...';

        updateStatusUI(currentStep, 'active', statusMsg);
        log(`Generating ${isFinalResponse ? 'final' : 'initial'} Gemini response...`);

        let context = '';
        const validSources = [];
        let sourceCounter = 0;

        const addResultsToContext = (results) => {
            results.forEach((r) => {
                sourceCounter++;
                const sourceNum = sourceCounter;

                const isFailure = r.content?.startsWith('크롤링 실패')
                    || r.content?.startsWith('크롤링 건너뜀')
                    || r.content?.startsWith('지원하지 않는 콘텐츠 타입')
                    || r.content?.startsWith('[정보 없음]');
                const isSnippet = r.content?.startsWith('[스니펫 요약]');

                if ((!isFailure || isSnippet) && r.content?.trim()) {
                    context += `[출처 ${sourceNum}: ${r.title}]\n${r.content}\n\n---\n\n`;
                    validSources.push({ ...r, sourceNum });
                }
            });
        };

        addResultsToContext(processedResults.initial);
        if (isFinalResponse && processedResults.followUp && processedResults.followUp.length > 0) {
            context += "\n\n===== 추가 검색 결과 =====\n\n";
            addResultsToContext(processedResults.followUp);
        }

        if (!context) {
            updateStatusUI(currentStep, 'active', '유효 정보 없음');
            return "웹에서 유의미한 정보를 찾지 못했습니다.";
        }

        const systemInstruction = `당신은 제공된 웹 검색 결과(출처)를 바탕으로 사용자 질문에 답변하는 AI 챗봇입니다.
- 각 출처는 '[출처 번호: 제목]' 형식으로 시작합니다.
- 내용을 분석하여 사용자의 질문에 대해 정확하고 상세하게, 한국어로 답변하세요.
- 답변 내용 중 특정 출처를 참고한 부분이 있다면, 해당 문장 끝에 '[출처 번호]' 형식으로 반드시 명시하세요. (예: ... 입니다 [출처 1].)
- 여러 출처를 종합한 경우, 관련된 모든 출처 번호를 명시하세요. (예: ... 입니다 [출처 1][출처 3].)
- 출처 내용만으로 답변하기 어렵거나 정보가 부족하면, "제공된 정보만으로는 답변하기 어렵습니다." 등의 문구로 정확히 알려주세요.
${isFinalResponse ? "이것은 최종 답변입니다. (추가 검색결과 포함)" : "이것은 초기 답변입니다. (1차 검색 결과 기반)"}
`;

        const requestPayload = {
            contents: [{
                role: "user",
                parts: [{
                    text: `System Instructions:\n${systemInstruction}\n\n---\n\n사용자 질문:\n${question}\n\n---\n\n웹 검색 결과 (참고 자료):\n${context}`
                }]
            }],
            safetySettings: [
                { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
            ],
            generationConfig: { temperature: isFinalResponse ? 0.6 : 0.5 }
        };
        const model = "gemini-2.0-flash";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(requestPayload)
            });
            const data = await response.json();

            if (!response.ok || data.error) {
                throw new Error(`Gemini API 오류 (${isFinalResponse?"최종":"초기"}): ${data.error ? data.error.message : `HTTP ${response.status}`}`);
            }
            if (!data.candidates || !data.candidates[0].content) {
                throw new Error(`Gemini 응답 없음 (${isFinalResponse?"최종":"초기"})`);
            }

            updateStatusUI(currentStep, 'active', '생각 완료');
            let answer = data.candidates[0].content.parts[0].text;

            // 출처 링크 달기
            validSources.forEach(src => {
                const regex = new RegExp(`\\[출처\\s?${src.sourceNum}\\]`, "g");
                const linkHtml = `<a href="${escapeHtml(src.link)}" target="_blank" class="source-link" title="${escapeHtml(src.title)}">[출처 ${src.sourceNum}]</a>`;
                answer = answer.replace(regex, linkHtml);
            });

            // 간단한 마크다운 → HTML
            answer = answer
                .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>')
                .replace(/\*(.*?)\*/g, '<em>$1</em>')
                .replace(/`([^`]+)`/g, '<code>$1</code>')
                .replace(/^###+\s+(.*)/gm, '<h5>$1</h5>')
                .replace(/^##\s+(.*)/gm, '<h4>$1</h4>')
                .replace(/^#\s+(.*)/gm, '<h3>$1</h3>')
                .replace(/^\s*[\-\*]\s+(.*)/gm, '<li>$1</li>')
                .replace(/(<li>.*<\/li>\s*)+/g, '<ul>$&</ul>')
                .replace(/\n/g, '<br>')
                .replace(/<\/ul><br>/g, '</ul>')
                .replace(/<br><ul>/g, '<ul>')
                .replace(/<li><br>/g, '<li>')
                .replace(/<br><\/li>/g, '</li>');

            return { answer, sources: validSources };

        } catch (error) {
            log(`Gemini API Exception: ${error}`);
            updateStatusUI(currentStep, 'active', '생각 중 오류 발생');
            return `Gemini ${isFinalResponse?"최종":"초기"} 응답 오류: ${error.message}`;
        }
    }

    // --- Main Message Processing ---
    async function processMessage(message) {
        addUserMessage(message);
        setLoadingState(true);

        let initialSearchResults = [];
        let initialProcessedResults = [];
        let followUpSearchResults = [];
        let followUpProcessedResults = [];
        let allOriginalSearchResults = [];

        try {
            // STAGE 1
            updateStatusUI(1, 'active', 'Google 검색 중...');
            initialSearchResults = await googleSearch(message, 8);
            allOriginalSearchResults = [...initialSearchResults];
            if (!initialSearchResults.length) {
                updateStatusUI(1, 'completed', '관련 웹페이지 없음');
                addBotMessage('관련 웹페이지를 찾을 수 없습니다. 다른 검색어나 질문을 시도해 보세요.');
                return;
            }
            updateStatusUI(1, 'completed', `${initialSearchResults.length}개 결과 찾음`);

            // STAGE 2
            const initialPagesToCrawl = initialSearchResults.map(r => ({
                link: r.link, title: r.title, snippet: r.snippet
            }));
            initialProcessedResults = await crawlWebpages(initialPagesToCrawl, 2);
            updateStatusUI(2, 'completed', '초기 분석 완료');

            // 스니펫 대체
            initialProcessedResults = initialProcessedResults.map(result => {
                const crawlFailed = result.status === 'rejected'
                    || result.content?.startsWith('크롤링 실패')
                    || result.content?.startsWith('크롤링 건너뜀')
                    || result.content?.startsWith('지원하지 않는 콘텐츠 타입');
                const hasSnippet = result.snippet && result.snippet.trim() !== '';
                if (crawlFailed && hasSnippet) {
                    return { ...result, content: `[스니펫 요약] ${result.snippet}`, status: 'fulfilled_with_snippet' };
                } else if (crawlFailed) {
                    return { ...result, content: `[정보 없음] ${result.content||'크롤링 실패'}`, status: 'rejected_no_snippet' };
                }
                return { ...result, status: 'fulfilled' };
            });

            // STAGE 3 (초기 Gemini 답변)
            const initialDataForGemini = { initial: initialProcessedResults };
            const initialGeminiResult = await getGeminiResponse(message, initialDataForGemini, false);
            if (typeof initialGeminiResult === 'string' || !initialGeminiResult?.answer) {
                updateStatusUI(3, 'completed', '초기 생각 오류');
                addBotMessage(typeof initialGeminiResult === 'string' ? initialGeminiResult : "초기 답변 생성 실패");
                return;
            }
            const initialAnswerText = initialGeminiResult.answer;
            updateStatusUI(3, 'completed', '초기 답변 완료');

            // 추가 검색어 생성
            const followUpQueries = await generateFollowUpQueries(message, initialAnswerText);
            updateStatusUI(3, 'completed', followUpQueries.length ? `${followUpQueries.length}개 추가 검색어 생성` : '추가 검색어 없음');

            // STAGE 4
            if (!followUpQueries.length) {
                updateStatusUI(4, 'completed', '추가 검색 건너뜀');
            } else {
                updateStatusUI(4, 'active', `추가 정보 검색 중 (${followUpQueries.length}개)...`);
                const promises = followUpQueries.map(q => googleSearch(q, 3));
                const nestedResults = await Promise.all(promises);
                followUpSearchResults = nestedResults.flat();
                allOriginalSearchResults.push(...followUpSearchResults);

                if (followUpSearchResults.length) {
                    const followUpPages = followUpSearchResults.map(r => ({
                        link: r.link, title: r.title, snippet: r.snippet
                    }));
                    followUpProcessedResults = await crawlWebpages(followUpPages, 4);
                    followUpProcessedResults = followUpProcessedResults.map(result => {
                        const crawlFailed = result.status === 'rejected'
                            || result.content?.startsWith('크롤링 실패')
                            || result.content?.startsWith('크롤링 건너뜀')
                            || result.content?.startsWith('지원하지 않는 콘텐츠 타입');
                        const hasSnippet = result.snippet && result.snippet.trim() !== '';
                        if (crawlFailed && hasSnippet) {
                            return { ...result, content: `[스니펫 요약] ${result.snippet}`, status: 'fulfilled_with_snippet' };
                        } else if (crawlFailed) {
                            return { ...result, content: `[정보 없음] ${result.content||'크롤링 실패'}`, status: 'rejected_no_snippet' };
                        }
                        return { ...result, status: 'fulfilled' };
                    });
                    updateStatusUI(4, 'completed', '추가 분석 완료');
                } else {
                    updateStatusUI(4, 'completed', '추가 검색 결과 없음');
                }
            }

            // STAGE 5 (최종 Gemini 답변)
            const finalDataForGemini = { initial: initialProcessedResults, followUp: followUpProcessedResults };
            const finalGeminiResult = await getGeminiResponse(message, finalDataForGemini, true, initialAnswerText);
            if (typeof finalGeminiResult === 'string' || !finalGeminiResult?.answer) {
                updateStatusUI(5, 'completed', '최종 생각 오류');
                addBotMessage(typeof finalGeminiResult === 'string' ? finalGeminiResult : "최종 답변 생성 실패");
                return;
            }
            updateStatusUI(5, 'completed', '답변 준비 완료!');

            const finalAnswerHtml = finalGeminiResult.answer;
            const botMsgEl = addBotMessage(finalAnswerHtml, true);

            // 원본 검색 결과 리스트 표시
            if (botMsgEl && allOriginalSearchResults.length) {
                const sourcesDiv = document.createElement('div');
                sourcesDiv.className = 'mt-4 pt-4 border-t border-gray-200 text-sm no-print';
                let sourcesHtml = `<p class="font-medium mb-2">참고한 원본 검색 결과 (1차 및 2차 포함):</p><ul class="list-disc list-inside space-y-1">`;
                const linkSet = new Set();
                allOriginalSearchResults.forEach(res => {
                    if (res && res.link && !linkSet.has(res.link)) {
                        linkSet.add(res.link);
                        sourcesHtml += `<li><a href="${escapeHtml(res.link)}" target="_blank" class="source-link" title="${escapeHtml(res.snippet||'')}">${escapeHtml(res.title)}</a></li>`;
                    }
                });
                sourcesHtml += '</ul>';
                sourcesDiv.innerHTML = sourcesHtml;
                botMsgEl.appendChild(sourcesDiv);
                scrollToBottom();
            }

        } catch (error) {
            log('오류 발생:', error);
            const activeStep = document.querySelector('.status-item.status-active');
            if (activeStep) {
                updateStatusUI(activeStep.dataset.step, 'completed', '오류 발생');
            }
            addBotMessage(`처리 중 오류가 발생했습니다: ${error.message}`);
        } finally {
            setLoadingState(false);
        }
    }

    // --- Event Listeners ---
    sendButton.addEventListener('click', () => {
        const message = userInput.value.trim();
        if (message && !sendButton.disabled) {
            userInput.value = '';
            userInput.focus();
            processMessage(message);
        }
    });

    userInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) {
            e.preventDefault();
            sendButton.click();
        }
    });

    // 초기화
    log("챗봇 초기화 완료");
    userInput.focus();
</script>
</body>
</html>
