<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>검색 기반 Gemini 챗봇</title> <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <script src="config.js"></script> <style>
        body {
            transition: background-color 0.3s, color 0.3s;
        }
        .dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .chat-container {
            height: calc(100vh - 180px); /* Adjusted for potential footer/header */
            min-height: 400px;
        }
        .user-message {
            background-color: #e3f2fd;
            border-radius: 18px 18px 2px 18px;
            /* Align user messages to the right */
            margin-left: auto;
            margin-right: 0;
        }
        .bot-message {
            background-color: #f1f1f1;
            border-radius: 18px 18px 18px 2px;
             /* Align bot messages to the left */
            margin-left: 0;
            margin-right: auto;
        }
        .dark .user-message {
            background-color: #2d3748;
        }
        .dark .bot-message {
            background-color: #4a5568;
        }
        /* Progress Bar Styles */
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden; /* Ensure progress bar stays within bounds */
        }
        .progress-bar {
            height: 100%;
            border-radius: 4px 0 0 4px; /* Slightly rounded left edge */
            width: 0%;
            background-color: #4299e1;
            transition: width 0.3s ease-in-out; /* Smoother transition */
        }
        .dark .progress-container {
            background-color: #2d3748;
        }
        .progress-status {
            margin-top: 5px;
            font-size: 12px;
            color: #718096;
            text-align: center; /* Center status text */
        }
        .dark .progress-status {
            color: #a0aec0;
        }
        /* Source Link Styles */
        .source-link {
            color: #3182ce;
            text-decoration: underline;
            word-break: break-all; /* Break long links */
        }
        .dark .source-link {
            color: #90cdf4;
        }
        .source-link:hover {
            text-decoration: none; /* Optional: remove underline on hover */
        }
        /* Typing Indicator Styles */
        .ellipsis {
            display: inline-block;
            width: 60px; /* Fixed width for alignment */
            text-align: left;
        }
        .typing-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: currentColor; /* Use current text color */
            margin-right: 4px;
            animation: typing 1s infinite;
        }
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typing {
            0%, 100% { opacity: 0.3; transform: translateY(0); }
            50% { opacity: 1; transform: translateY(-2px); }
        }
         /* Print Styles */
        @media print {
            .no-print { display: none !important; }
            body { background-color: #fff; color: #000; }
            .dark { background-color: #fff; color: #000; } /* Force light mode for print */
            .dark .user-message, .dark .bot-message { background-color: #f1f1f1; color: #000; }
            .user-message, .bot-message { background-color: #f1f1f1; }
            .chat-container { height: auto; max-height: none; overflow: visible; }
            .source-link { color: #0000EE; text-decoration: underline; } /* Standard link blue for print */
            .print-break { page-break-before: always; }
             #chat-form, #progress-section, #theme-toggle { display: none; } /* Hide form/controls */
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="flex justify-between items-center mb-6 no-print">
            <h1 class="text-3xl font-bold text-gray-800 dark:text-white">검색 기반 Gemini 챗봇</h1>
            <div class="flex space-x-4">
                <button id="theme-toggle" class="px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition focus:outline-none focus:ring-2 focus:ring-gray-500">
                    <i class="fas fa-moon"></i> </button>
                 <button onclick="window.print()" class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <i class="fas fa-print"></i>
                </button>
            </div>
        </div>

        <div id="chat-box" class="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <div id="chat-messages" class="chat-container p-4 overflow-y-auto space-y-4">
                <div class="bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl">
                    <p>안녕하세요! 검색 기반 Gemini 챗봇입니다. 궁금한 점이 있으시면 질문해주세요. 제가 구글 검색과 웹페이지 분석(실패 시 요약 정보 활용)을 통해 답변해 드리겠습니다.</p>
                </div>
            </div>

            <div id="chat-form" class="p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 no-print">
                <div class="max-w-3xl mx-auto">
                    <div id="progress-section" class="mb-3 hidden">
                        <div id="progress-status" class="progress-status"></div>
                        <div class="progress-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <input type="text" id="user-input" class="flex-grow px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" placeholder="질문을 입력하세요...">
                        <button id="send-button" class="px-4 py-2 bg-blue-500 text-white rounded-r-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50" aria-label="Send message">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-6 text-sm text-gray-600 dark:text-gray-400 text-center no-print">
            <p>© 2025 검색 기반 Gemini 챗봇 by 수현</p>
        </div>
    </div>

    <script>
        // --- Basic Setup ---
        const DEBUG = true; // Enable console logging
        function log(...args) {
            if (DEBUG) {
                console.log('[챗봇 로그]', new Date().toISOString(), ...args);
            }
        }

        // Check if API keys are loaded from config.js
        if (typeof apiKeys === 'undefined') {
            console.error("API Keys not found! Make sure config.js is loaded correctly and defines the 'apiKeys' object.");
            alert("API Keys 설정 파일을 찾을 수 없습니다. config.js 파일이 올바르게 로드되었는지 확인하세요.");
        }

        // --- DOM Elements ---
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const progressSection = document.getElementById('progress-section');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const body = document.body;

        // --- Dark Mode ---
        function applyTheme(isDark) {
            if (isDark) {
                body.classList.add('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>'; // Show sun icon in dark mode
            } else {
                body.classList.remove('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>'; // Show moon icon in light mode
            }
        }
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
        let currentModeIsDark = localStorage.getItem('dark-mode') === 'true' || (localStorage.getItem('dark-mode') === null && prefersDark.matches);
        applyTheme(currentModeIsDark); // Apply theme on initial load

        themeToggleBtn.addEventListener('click', () => {
            currentModeIsDark = !currentModeIsDark;
            localStorage.setItem('dark-mode', currentModeIsDark ? 'true' : 'false');
            applyTheme(currentModeIsDark);
        });
        // Listen for system theme changes
         prefersDark.addEventListener('change', (e) => {
             // Only change if user hasn't manually overridden theme
             if (localStorage.getItem('dark-mode') === null) {
                currentModeIsDark = e.matches;
                applyTheme(currentModeIsDark);
             }
         });


        // --- Cache System ---
        const cache = {
            search: new Map(),
            crawl: new Map(),
            maxAge: 30 * 60 * 1000, // 30 minutes validity
            getSearch(query) {
                const item = this.search.get(query);
                if (item && (Date.now() - item.timestamp < this.maxAge)) {
                    log('Search cache hit:', query);
                    return item.data;
                }
                log('Search cache miss:', query);
                return null;
            },
            setSearch(query, data) {
                this.search.set(query, { data, timestamp: Date.now() });
                log('Search cache set:', query);
            },
            getCrawl(url) {
                const item = this.crawl.get(url);
                if (item && (Date.now() - item.timestamp < this.maxAge)) {
                    log('Crawl cache hit:', url);
                    return item.data;
                }
                log('Crawl cache miss:', url);
                return null;
            },
            setCrawl(url, data) {
                this.crawl.set(url, { data, timestamp: Date.now() });
                log('Crawl cache set:', url, 'Length:', data?.length);
            }
        };

        // --- UI Update Functions ---
        function escapeHtml(unsafe) {
            if (unsafe === null || typeof unsafe === 'undefined') return '';
             return unsafe
                 .toString() // Ensure it's a string
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
         }

        function addUserMessage(message) {
            const messageDiv = document.createElement('div');
            // Use max-w-xl or max-w-2xl for slightly wider user messages if needed
            messageDiv.className = 'user-message p-3 md:p-4 text-gray-800 dark:text-gray-200 max-w-3xl ml-auto mb-4';
            messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`; // Escape user input for security
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addBotMessage(message, isHTML = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-3 md:p-4 text-gray-800 dark:text-gray-200 max-w-3xl mr-auto mb-4';
            // Sanitize HTML if isHTML is true (basic example)
            // For production, use a robust sanitizer like DOMPurify
            if (isHTML) {
                 // Basic sanitization (replace with DOMPurify if possible)
                 const sanitizedHTML = message.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); // Remove script tags
                 messageDiv.innerHTML = sanitizedHTML;
            } else {
                messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            }
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv; // Return element for potential modification (like adding sources)
        }

         function addLoadingMessage() {
            const existingLoading = document.getElementById('loading-message');
            if (existingLoading) return existingLoading; // Don't add multiple

            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl mr-auto mb-4';
            messageDiv.id = 'loading-message';
            const loadingSpan = document.createElement('span');
            loadingSpan.className = 'ellipsis';
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('span');
                dot.className = 'typing-dot';
                loadingSpan.appendChild(dot);
            }
            messageDiv.appendChild(loadingSpan); // Add ellipsis span
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

         function updateLoadingMessage(message) {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                 const ellipsisSpan = loadingMessage.querySelector('.ellipsis');
                 // Update text content before the ellipsis
                 loadingMessage.childNodes[0].nodeValue = escapeHtml(message) + ' ';
                 if (!ellipsisSpan) { // Make sure ellipsis is still there
                     const newEllipsisSpan = document.createElement('span');
                     newEllipsisSpan.className = 'ellipsis';
                     // Recreate dots if needed
                      for (let i = 0; i < 3; i++) {
                           const dot = document.createElement('span');
                           dot.className = 'typing-dot';
                           newEllipsisSpan.appendChild(dot);
                       }
                     loadingMessage.appendChild(newEllipsisSpan);
                 }
            } else {
                // If loading message was removed somehow, add it again
                 addLoadingMessage();
                 updateLoadingMessage(message); // Call again to set the text
            }
        }


        function removeLoadingMessage() {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.remove();
            }
        }

        function updateProgress(percent, statusText) {
            progressBar.style.width = `${Math.min(100, Math.max(0, percent))}%`; // Clamp between 0-100
            progressStatus.textContent = statusText;

            if (percent > 0 && progressSection.classList.contains('hidden')) {
                progressSection.classList.remove('hidden');
            }

            if (percent >= 100) {
                // Hide progress bar shortly after completion
                setTimeout(() => {
                    if (progressBar.style.width === '100%') { // Check if it's still 100% before hiding
                         progressSection.classList.add('hidden');
                         progressBar.style.width = '0%'; // Reset for next time
                         progressStatus.textContent = ''; // Clear status
                    }
                }, 1500); // Keep it visible for 1.5 seconds after 100%
            } else if (percent <= 0) {
                 // Hide immediately if progress is 0 or less
                 progressSection.classList.add('hidden');
                 progressBar.style.width = '0%';
                 progressStatus.textContent = '';
            }
        }

        function scrollToBottom() {
             // A small delay can help ensure rendering is complete before scrolling
             setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
             }, 50);
        }

         function setLoadingState(isLoading) {
            if (isLoading) {
                sendButton.disabled = true;
                userInput.disabled = true;
                sendButton.classList.add('disabled:opacity-50'); // Visual cue
                 addLoadingMessage(); // Show loading dots immediately
                 updateProgress(0, '시작 중...'); // Show progress bar immediately
            } else {
                sendButton.disabled = false;
                userInput.disabled = false;
                sendButton.classList.remove('disabled:opacity-50');
                 removeLoadingMessage();
                 // updateProgress handles hiding itself when >= 100%
            }
        }


        // --- Google Search API Call ---
        async function googleSearch(query) {
            const googleApiKey = apiKeys?.GOOGLE_API_KEY;
            const searchEngineId = apiKeys?.SEARCH_ENGINE_ID;
            if (!googleApiKey || !searchEngineId) {
                 throw new Error("Google Search API Key or Search Engine ID is missing in config.js");
            }

            updateProgress(10, '구글 검색 중...');
            const cachedResults = cache.getSearch(query);
            if (cachedResults) {
                updateProgress(20, '캐시된 검색 결과 사용 중...');
                return cachedResults;
            }

            try {
                const apiUrl = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&num=8`; // Fetch 8 results
                log("Google Search API Request:", apiUrl);
                const response = await fetch(apiUrl);
                const data = await response.json();

                if (!response.ok || data.error) {
                    log('Google Search API Error:', data.error || `HTTP ${response.status}`);
                    throw new Error(`Google 검색 API 오류: ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }
                updateProgress(20, '검색 결과 처리 중...');
                if (!data.items || data.items.length === 0) {
                     log("Google Search: 결과 없음");
                    return [];
                }
                // Extract relevant fields including snippet
                const results = data.items.map(item => ({
                    title: item.title,
                    link: item.link,
                    snippet: item.snippet, // Ensure snippet is captured
                    pagemap: item.pagemap // Might be useful for metadata later
                }));
                cache.setSearch(query, results); // Cache successful results
                return results;
            } catch (error) {
                log('Google 검색 중 예외 발생:', error);
                // Don't cache errors
                throw error; // Re-throw to be caught by processMessage
            }
        }

        // --- Web Crawling ---
        const proxies = [
             // Prioritize potentially more reliable proxies first
             { name: 'corsproxy.io', url: (targetUrl) => `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`, active: true },
             { name: 'allorigins', url: (targetUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`, active: true },
             // cors-anywhere is often rate-limited or requires activation
             // { name: 'corsanywhere', url: (targetUrl) => `https://cors-anywhere.herokuapp.com/${targetUrl}`, active: true }
        ];

        async function crawlWebpage(url, attempt = 0) {
            const cachedContent = cache.getCrawl(url);
            if (cachedContent) {
                return cachedContent; // Return cached data immediately
            }

            const activeProxies = proxies.filter(p => p.active);
             if (activeProxies.length === 0) {
                 log("크롤링 실패: 활성화된 프록시 없음", url);
                 // Consider reactivating all proxies here if none are left? Or handle upstream.
                 proxies.forEach(p => p.active = true); // Let's reactivate for next *different* URL.
                 return `크롤링 실패 (활성 프록시 없음): ${url}`;
             }

             const maxRetriesPerUrl = activeProxies.length; // Try each active proxy once per URL
             if (attempt >= maxRetriesPerUrl) {
                 log("크롤링 최대 재시도 도달:", url);
                  proxies.forEach(p => p.active = true); // Reactivate proxies for the next URL.
                 return `크롤링 실패 (최대 재시도): ${url}`;
             }

             const proxyIndex = attempt % activeProxies.length; // Cycle through active proxies
             const proxy = activeProxies[proxyIndex];

            log(`[${proxy.name}] 크롤링 시도 (${attempt + 1}/${maxRetriesPerUrl}):`, url);

            try {
                if (!url || !url.startsWith('http')) {
                    throw new Error(`유효하지 않은 URL: ${url}`);
                }
                // Basic file extension check (might miss some cases)
                 const path = url.split('?')[0]; // Ignore query parameters for extension check
                 const fileExtension = path.includes('.') ? path.split('.').pop().toLowerCase() : '';
                const nonHtmlExtensions = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'zip', 'rar', 'jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'mp3', 'mp4', 'avi', 'mov', 'exe', 'dmg'];
                if (nonHtmlExtensions.includes(fileExtension)) {
                     log(`크롤링 건너뜀 (파일 형식 ${fileExtension}): ${url}`);
                    return `크롤링 건너뜀 (파일 형식 ${fileExtension.toUpperCase()}): ${url}`;
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    log(`[${proxy.name}] 타임아웃 (15s): ${url}`);
                 }, 15000); // 15-second timeout

                const proxyUrl = proxy.url(url);
                const headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36', // Reasonably modern UA
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
                    'Upgrade-Insecure-Requests': '1', // Common browser header
                     'Sec-Fetch-Dest': 'document',
                     'Sec-Fetch-Mode': 'navigate',
                     'Sec-Fetch-Site': 'cross-site', // Indicate coming from different origin via proxy
                };

                const response = await fetch(proxyUrl, {
                    signal: controller.signal,
                    headers: headers,
                    mode: 'cors', // Necessary for cross-origin requests via proxies
                    referrerPolicy: 'strict-origin-when-cross-origin' // Common referrer policy
                 });
                clearTimeout(timeoutId); // Clear timeout if fetch completes

                if (!response.ok) {
                    // Read response body for more info if possible (but limit size)
                     let errorBody = '';
                     try { errorBody = await response.text(); } catch (_) {}
                     log(`[${proxy.name}] HTTP 오류 ${response.status} (${response.statusText}). 응답 일부: ${errorBody.substring(0, 200)}...`);
                     throw new Error(`HTTP 오류 ${response.status}`); // Simplified error for propagation
                }

                const contentType = response.headers.get('content-type') || '';
                 log(`[${proxy.name}] 응답 Content-Type: ${contentType}`, url);
                 if (!contentType.includes('text/html') && !contentType.includes('application/xhtml+xml') && !contentType.includes('text/plain')) {
                    if (contentType.includes('application/json')) {
                        try {
                            const json = await response.json();
                            const textContent = `JSON 데이터:\n${JSON.stringify(json, null, 2)}`.substring(0, 8000);
                            cache.setCrawl(url, textContent); // Cache JSON content
                            return textContent;
                        } catch (e) { return `JSON 파싱 오류. Content-Type: ${contentType}, URL: ${url}`; }
                     } else if (contentType.includes('xml') && !contentType.includes('xhtml')) { // Handle general XML
                         try {
                             const xmlText = await response.text();
                             const textContent = `XML 데이터:\n${xmlText}`.substring(0, 8000);
                              cache.setCrawl(url, textContent); // Cache XML content
                             return textContent;
                         } catch (e) { return `XML 파싱 오류. Content-Type: ${contentType}, URL: ${url}`; }
                     }
                     log(`지원하지 않는 Content-Type: ${contentType}, URL: ${url}`);
                     return `지원하지 않는 콘텐츠 타입 (${contentType}): ${url}`;
                 }

                const html = await response.text();
                if (!html || html.trim().length === 0) {
                    throw new Error('빈 응답 또는 내용 없음');
                }

                 // --- HTML Parsing and Content Extraction ---
                 const parser = new DOMParser();
                 const doc = parser.parseFromString(html, 'text/html');

                 // Try to get title and meta description
                 const title = doc.querySelector('title')?.textContent.trim() || url;
                 const metaDescription = doc.querySelector('meta[name="description"]')?.getAttribute('content')?.trim() || '';

                 // Remove common non-content elements aggressively
                 const elementsToRemove = ['script', 'style', 'svg', 'img', 'picture', 'video', 'audio', 'iframe', 'nav', 'header', 'footer', 'aside', 'form', 'noscript', 'button', 'input', 'select', 'textarea', 'label', 'canvas', 'map', 'object', 'embed', '.advertisement', '.ad', '#ad', '.banner', '.popup', '.modal', '.sidebar', '.social-links', '.share-buttons', '.cookie-consent', '[aria-hidden="true"]'];
                 elementsToRemove.forEach(selector => {
                     try { // Add try-catch for potentially invalid selectors
                         doc.querySelectorAll(selector).forEach(el => el.remove());
                     } catch (e) {
                         log(`CSS Selector 오류 무시 (${selector}):`, e.message);
                     }
                 });

                 // Attempt to find the main content area
                  let mainContent = doc.querySelector('main') ||
                                   doc.querySelector('article') ||
                                   doc.querySelector('[role="main"]') ||
                                   doc.querySelector('.content, .main-content, .post-content, .entry-content, #content, #main, .article-body, .entry, .page-content'); // Added more selectors

                 if (!mainContent || mainContent.textContent.trim().length < 100) { // Fallback if main is too small or not found
                     mainContent = doc.body;
                 }

                 // Extract text content, trying to preserve structure somewhat
                  let text = '';
                  const significantTags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre', 'div', 'td']; // Add div, td
                  function extractTextNodes(node) {
                      let nodeText = '';
                      for (const child of node.childNodes) {
                          if (child.nodeType === Node.TEXT_NODE) {
                              nodeText += child.textContent;
                          } else if (child.nodeType === Node.ELEMENT_NODE) {
                               const tagName = child.tagName.toLowerCase();
                               const displayStyle = window.getComputedStyle(child).display; // Check display style
                              // Add newline before block-level or significant elements
                               if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && text.length > 0 && !text.endsWith('\n')) {
                                  nodeText += '\n';
                              }
                              nodeText += extractTextNodes(child); // Recurse
                               // Add newline after block-level or significant elements
                               if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && !nodeText.endsWith('\n')) {
                                  nodeText += '\n';
                              }
                          }
                      }
                      return nodeText;
                  }

                 text = extractTextNodes(mainContent);


                 // Clean up extracted text
                 text = text.replace(/(\s*\n\s*){3,}/g, '\n\n') // Reduce multiple blank lines to max 2
                            .replace(/[ \t]{2,}/g, ' ')      // Reduce multiple spaces/tabs to one space
                            .replace(/^\s+|\s+$/gm, '')     // Trim whitespace from each line
                            .trim();                         // Trim leading/trailing whitespace from the whole string

                 // Add Title and Description at the beginning
                  text = `제목: ${title}\n${metaDescription ? '설명: ' + metaDescription + '\n' : ''}\n---\n\n${text}`;


                 // Check length and truncate if necessary
                 const maxLength = 8000;
                 if (text.length > maxLength) {
                     text = text.substring(0, maxLength) + '... [내용 중략됨]';
                     log(`크롤링 내용 축약됨 (>${maxLength} chars): ${url}`);
                 }

                 if (!text || text.length < 50) { // Check if extracted text is meaningful
                     log(`[${proxy.name}] 유의미한 내용 추출 부족: ${url}, 길이: ${text.length}`);
                     // Treat as failure if too short? Or let Gemini decide? Let's return it for now.
                 }

                 log('크롤링 성공:', url, '길이:', text.length);
                 cache.setCrawl(url, text); // Cache the processed text
                 proxies.forEach(p => p.active = true); // Success, ensure all proxies are active for next different URL.
                 return text;

            } catch (error) {
                log(`[${proxy.name}] '${url}' 크롤링 중 예외 (${attempt + 1}/${maxRetriesPerUrl}):`, error);

                 // Deactivate the failing proxy *temporarily* for this specific URL's retries
                 proxy.active = false;
                 log(`${proxy.name} 프록시 비활성화됨 (현재 URL 재시도용)`);


                 // Retry with the next proxy for the *same* URL
                 return crawlWebpage(url, attempt + 1);
            }
        }


        // Parallel Web Crawling Function
        async function crawlWebpages(pagesToCrawl) {
            const totalSites = pagesToCrawl.length;
            updateProgress(30, `웹페이지 분석 시작 (0/${totalSites})...`);
            log(`${totalSites}개 사이트 크롤링/분석 시작`);

            let completedCount = 0;
             // Use Promise.allSettled to ensure all crawls complete, regardless of individual errors
            const crawlPromises = pagesToCrawl.map(async (pageInfo, index) => {
                 try {
                      // Reset proxy activity status before each unique URL crawl starts
                      proxies.forEach(p => p.active = true);
                     const content = await crawlWebpage(pageInfo.link); // Start attempt 0 for each
                      completedCount++;
                     updateProgress(30 + Math.floor(completedCount * 40 / totalSites), `${totalSites}개 중 ${completedCount}개 사이트 분석 완료`);
                     return { ...pageInfo, content, status: 'fulfilled' }; // Return original info + content + status
                 } catch (error) {
                     // This catch block might be less likely to hit if crawlWebpage handles internal errors
                     log(`crawlWebpages 내 예외 발생 (사이트 ${pageInfo.link}):`, error);
                     completedCount++;
                     updateProgress(30 + Math.floor(completedCount * 40 / totalSites), `${totalSites}개 중 ${completedCount}개 사이트 분석 완료 (오류 포함)`);
                     return { ...pageInfo, content: `크롤링 중 예상치 못한 오류: ${error.message}`, status: 'rejected' };
                 }
            });

            // Wait for all promises to settle
            const results = await Promise.allSettled(crawlPromises);
             log('모든 사이트 크롤링/분석 시도 완료');
            updateProgress(70, '분석 완료, 응답 생성 준비 중...');

             // Process results from Promise.allSettled
             return results.map(result => {
                 if (result.status === 'fulfilled') {
                     return result.value; // Contains { ...pageInfo, content, status: 'fulfilled' }
                 } else {
                     // Log the reason for rejection if needed
                     log("Promise Settled Error:", result.reason);
                      // Return a structure indicating failure, potentially using info from reason if available
                      // For simplicity, let's assume the structure from the catch block above is sufficient
                      // If result.reason contains the structure, use it, otherwise create a generic failure one.
                      if (result.reason && typeof result.reason === 'object' && result.reason.link) {
                          return result.reason; // Assume reason contains the error structure
                      } else {
                          // Create a generic failure structure - needs link/title/snippet from original input
                          // This part is tricky without passing the original input here again.
                           // Let's rely on the structure returned from the map's catch block for now.
                           // Need to ensure pageInfo is accessible here if the inner catch fails.
                            // A better pattern might involve Promise.all directly on crawlWebpage calls
                            // and handling errors in the .then/.catch chain as currently implemented.
                            // Let's stick with the current Promise.all on the async map function.
                           log("경고: Promise.allSettled에서 예상치 못한 rejection 구조:", result.reason);
                           // Returning a placeholder - this needs refinement if errors aren't caught inside the map.
                            return { link: 'unknown', title: 'Unknown Error', snippet: '', content: `크롤링 실패: ${result.reason}`, status: 'rejected' };
                      }

                 }
             });
        }

        // --- Google Gemini API Call ---
        async function getGeminiResponse(question, processedResults) {
            const geminiApiKey = apiKeys?.GEMINI_API_KEY;
            if (!geminiApiKey) {
                throw new Error("Gemini API Key is missing in config.js");
            }

            updateProgress(75, 'Gemini 응답 생성 중...');
            log('Gemini 요청 준비 중...');

            // Build context string for Gemini
            let context = '';
            const validSourcesForPrompt = []; // Track sources actually used in context
            processedResults.forEach((result, index) => {
                // Include content if it's not clearly a failure message and not empty
                 // Note: We now include snippets prefixed with "[스니펫 요약]"
                if (result.content && !result.content.startsWith('크롤링 실패') && !result.content.startsWith('크롤링 건너뜀') && !result.content.startsWith('지원하지 않는 콘텐츠 타입')) {
                    context += `[출처 ${index + 1}: ${result.title}]\n${result.content}\n\n---\n\n`;
                    validSourcesForPrompt.push({...result, sourceNum: index + 1}); // Store source number
                } else {
                    log(`Gemini 컨텍스트에서 제외된 출처 ${index + 1} (${result.title}): 내용 부적절/실패`);
                }
            });

            if (!context) {
                 log("Gemini 요청 취소: 유효한 컨텍스트 정보 없음 (크롤링/스니펫 모두 실패)");
                 return "웹사이트에서 관련 정보를 찾거나 분석할 수 없었습니다. 다른 질문을 시도해 보세요.";
            }

            // Gemini API Request Structure
            const systemInstruction = `당신은 제공된 웹 검색 결과(출처)를 바탕으로 사용자 질문에 답변하는 AI 챗봇입니다.
- 각 출처는 '[출처 번호: 제목]' 형식으로 시작하며, 내용은 전체 웹페이지 텍스트, JSON/XML 데이터 요약, 또는 '[스니펫 요약]'으로 시작하는 짧은 요약일 수 있습니다.
- 내용을 분석하여 사용자의 질문에 대해 정확하고 상세하게, 한국어로 답변하세요.
- 답변 내용 중 특정 출처를 참고한 부분이 있다면, 해당 문장 끝에 '[출처 번호]' 형식으로 반드시 명시하세요. (예: ... 입니다 [출처 1].)
- 여러 출처를 종합한 경우, 관련된 모든 출처 번호를 명시하세요. (예: ... 입니다 [출처 1][출처 3].)
- 출처 내용만으로 답변하기 어렵거나 정보가 부족하면, "제공된 정보만으로는 답변하기 어렵습니다." 또는 "정보가 부족합니다." 라고 솔직하게 답변하세요. 추측하거나 외부 지식을 사용하지 마세요.
- 답변 마지막에는 "참고 자료:" 섹션을 만들고, 답변 생성에 '실제로 사용된' 모든 출처의 번호, 제목, 원본 링크를 목록 형식으로 제공하세요. (예: * 출처 1: [제목] - [링크])`;

             const requestPayload = {
                contents: [
                    { // Combine instructions, question, and context for the first user turn
                        role: "user",
                        parts: [{
                            text: `System Instructions:\n${systemInstruction}\n\n---\n\n사용자 질문:\n${question}\n\n---\n\n웹 검색 결과 (참고 자료):\n${context}`
                        }]
                    }
                    // Add previous conversation turns here if implementing history
                ],
                // Safety Settings (Optional but recommended)
                safetySettings: [
                  { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ],
                generationConfig: {
                    temperature: 0.6, // Slightly lower temperature for more factual answers based on context
                    // maxOutputTokens: 2048, // Limit response length if needed
                    // topP: 0.9,
                    // topK: 40
                }
            };

            // Use a recommended Gemini model (e.g., gemini-1.5-flash-latest)
            const model = "gemini-1.5-flash-latest"; // Or "gemini-pro"
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

            log('Gemini API 요청 전송:', apiUrl);
            // Avoid logging the full payload in production due to potentially large context size
             if (DEBUG) {
                  // Log a truncated version or just structure keys
                  // log('Gemini 요청 본문 (일부):', JSON.stringify(requestPayload).substring(0, 500) + '...');
             }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload)
                });

                const data = await response.json();

                // Handle API errors
                if (!response.ok || data.error) {
                    log('Gemini API 오류 응답:', data);
                    throw new Error(`Gemini API 오류: ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }

                // Handle safety blocks or empty responses
                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                    const feedback = data.promptFeedback || data.candidates?.[0]?.finishReason;
                    log('Gemini 응답 없음 또는 안전 필터링:', feedback);
                    const reason = data.candidates?.[0]?.finishReason || data.promptFeedback?.blockReason || 'Unknown';
                    let message = `Gemini가 응답을 생성하지 못했습니다. 이유: ${reason}.`;
                    if (data.promptFeedback?.safetyRatings) {
                         message += ` (안전 평가: ${data.promptFeedback.safetyRatings.map(r => `${r.category}: ${r.probability}`).join(', ')})`;
                    }
                     // Return this specific message instead of throwing an error
                     updateProgress(100, '응답 생성 실패 (필터링)');
                     return message; // Return the message to be displayed to the user
                 }


                updateProgress(100, '응답 생성 완료');
                log('Gemini 응답 받음');

                let answer = data.candidates[0].content.parts[0].text;

                 // --- Post-processing Gemini Response ---

                 // 1. Link Citations: Replace [출처 N] with actual links
                 validSourcesForPrompt.forEach(source => {
                     // Regex to find [출처 N], potentially with spaces or multiple citations like [출처 1][출처 3]
                     const citationRegex = new RegExp(`\\[출처\\s?${source.sourceNum}\\]`, 'g');
                     const sourceLink = `<a href="${escapeHtml(source.link)}" target="_blank" class="source-link" title="${escapeHtml(source.title)}">[출처 ${source.sourceNum}]</a>`;
                     answer = answer.replace(citationRegex, sourceLink);
                 });

                 // 2. Link "참고 자료" List (if generated by Gemini)
                 // This relies heavily on Gemini following the format instruction.
                 answer = answer.replace(/(\*?\s*출처\s*(\d+)\s*:\s*)(.*?)\s*-\s*(https?:\/\/[^\s<]+)/g, (match, prefix, num, title, link) => {
                     // Find the corresponding source data
                     const source = validSourcesForPrompt.find(s => s.sourceNum === parseInt(num));
                     if (source) {
                          // Use the original link from our data for accuracy
                          return `${prefix.trim()} <a href="${escapeHtml(source.link)}" target="_blank" class="source-link">${escapeHtml(title.trim())}</a>`;
                     }
                     return match; // Return original if source not found
                 });
                 // Fallback attempt to link titles if the format is slightly different
                 validSourcesForPrompt.forEach(source => {
                      const titleRegex = new RegExp(`(${escapeHtml(source.title)})`, 'g'); // Escape title for regex
                      // Only replace if not already inside an <a> tag
                      answer = answer.replace(titleRegex, (match, capturedTitle) => {
                          // Very basic check to avoid nested links
                           const surroundingChars = answer.substring(answer.indexOf(match) - 10, answer.indexOf(match) + match.length + 10);
                           if (surroundingChars.includes('<a href')) { return capturedTitle; } // Already linked likely
                           return `<a href="${escapeHtml(source.link)}" target="_blank" class="source-link">${capturedTitle}</a>`;
                      });
                 });


                 // 3. Basic Markdown to HTML conversion
                 answer = answer.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // Bold
                 answer = answer.replace(/\*(.*?)\*/g, '<em>$1</em>');   // Italics
                 answer = answer.replace(/`([^`]+)`/g, '<code>$1</code>'); // Inline code
                 // Convert Markdown headings (basic) - adjust level as needed
                 answer = answer.replace(/^###+\s+(.*)/gm, '<h5>$1</h5>');
                 answer = answer.replace(/^##\s+(.*)/gm, '<h4>$1</h4>');
                 answer = answer.replace(/^#\s+(.*)/gm, '<h3>$1</h3>');
                 // Convert Markdown lists (basic)
                  answer = answer.replace(/^\s*[\-\*]\s+(.*)/gm, '<li>$1</li>');
                  answer = answer.replace(/(<li>.*<\/li>\s*)+/g, '<ul>$&</ul>'); // Wrap consecutive LIs in UL
                 // Convert newlines to <br> (do this last)
                 answer = answer.replace(/\n/g, '<br>');
                 // Clean up potential double <br> from list wrapping
                  answer = answer.replace(/<\/ul><br>/g, '</ul>');
                  answer = answer.replace(/<br><ul>/g, '<ul>');
                  answer = answer.replace(/<li><br>/g, '<li>');
                  answer = answer.replace(/<br><\/li>/g, '</li>');


                 return answer;

            } catch (error) {
                log('Gemini 응답 생성/처리 중 예외 발생:', error);
                updateProgress(100, '응답 처리 중 오류 발생');
                // Return the error message to be displayed by the bot
                return `Gemini 응답 처리 중 오류 발생: ${error.message}`;
            }
        }

        // --- Main Message Processing Orchestrator ---
        async function processMessage(message) {
             setLoadingState(true); // Disable input, show loading

            try {
                // 1. Google Search
                updateLoadingMessage('Google 검색 중...');
                const searchResults = await googleSearch(message);
                if (!searchResults || searchResults.length === 0) {
                    addBotMessage('관련 웹페이지를 찾을 수 없습니다. 다른 검색어나 질문을 시도해 보세요.');
                    updateProgress(100, '검색 결과 없음');
                     setLoadingState(false); // Re-enable input
                    return;
                }
                log("검색 결과:", searchResults.map(r => ({ link: r.link, snippet_exists: !!r.snippet })));

                // 2. Crawl Webpages (passing snippets)
                updateLoadingMessage('웹페이지 정보 분석 중...');
                const pagesToCrawl = searchResults.map(r => ({
                    link: r.link,
                    title: r.title,
                    snippet: r.snippet // Pass snippet
                }));
                const crawledResultsWithOriginalData = await crawlWebpages(pagesToCrawl);

                // 3. Apply Snippet Fallback Logic
                updateLoadingMessage('분석 결과 정리 중...');
                const resultsForGemini = crawledResultsWithOriginalData.map((result, index) => {
                    const crawlFailed = !result.content || result.content.startsWith('크롤링 실패') || result.content.startsWith('크롤링 건너뜀') || result.content.startsWith('지원하지 않는 콘텐츠 타입');
                    if (crawlFailed && result.snippet && result.snippet.trim() !== '') {
                        log(`크롤링 실패/건너뜀, 스니펫 사용: ${result.title}`);
                        return { ...result, content: `[스니펫 요약] ${result.snippet}`, sourceNum: index + 1 }; // Add sourceNum here
                    } else if (crawlFailed) {
                        log(`크롤링 실패/건너뜀/부적합, 스니펫 없음: ${result.title}`);
                        // Keep the failure message for context, or mark explicitly unusable
                        return { ...result, content: `[정보 없음] ${result.content}`, sourceNum: index + 1 }; // Mark as unusable but keep for numbering consistency
                    } else {
                         // Crawl successful
                        return { ...result, sourceNum: index + 1 }; // Add sourceNum
                    }
                });
                log("Gemini에게 전달할 최종 컨텐츠 개수:", resultsForGemini.length);


                // 4. Get Gemini Response
                if (resultsForGemini.length > 0) {
                    updateLoadingMessage('Gemini 응답 생성 중...');
                    const geminiResponse = await getGeminiResponse(message, resultsForGemini);

                     removeLoadingMessage(); // Remove loading indicator *before* adding final response
                    const botMsgElement = addBotMessage(geminiResponse, true); // Render response as HTML

                    // 5. Append Original Search Results List (Optional)
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.className = 'mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 no-print';
                    let sourcesHtml = '<p class="font-medium mb-2">참고한 원본 검색 결과:</p><ul class="list-disc list-inside space-y-1">';
                    searchResults.forEach((result, index) => {
                         // Use original search results here
                        sourcesHtml += `<li>(${index + 1}) <a href="${escapeHtml(result.link)}" target="_blank" class="source-link hover:underline" title="${escapeHtml(result.snippet)}">${escapeHtml(result.title)}</a></li>`;
                    });
                    sourcesHtml += '</ul>';
                    sourcesDiv.innerHTML = sourcesHtml;

                    // Append sources to the last bot message element if it exists
                    if (botMsgElement) {
                         botMsgElement.appendChild(sourcesDiv);
                         scrollToBottom(); // Scroll again after adding sources
                    }

                } else {
                    // Should be rare now, only if search finds nothing initially
                     removeLoadingMessage();
                    addBotMessage('관련 정보를 찾거나 처리할 수 없습니다.');
                    updateProgress(100, '처리할 내용 없음');
                }

            } catch (error) {
                log('전체 처리 중 오류 발생:', error);
                 removeLoadingMessage(); // Ensure loading is removed on error
                addBotMessage(`처리 중 오류가 발생했습니다: ${error.message}`);
                updateProgress(100, '오류 발생'); // Ensure progress completes on error
            } finally {
                 setLoadingState(false); // Re-enable input fields regardless of success/failure
                 // Ensure progress bar hides eventually
                 if (progressBar.style.width !== '100%') {
                      setTimeout(() => updateProgress(100, progressStatus.textContent || '완료'), 200);
                 }
            }
        }

        // --- Event Listeners ---
        sendButton.addEventListener('click', () => {
            const message = userInput.value.trim();
            if (message && !sendButton.disabled) { // Check if not already processing
                userInput.value = '';
                userInput.focus();
                processMessage(message);
            }
        });

        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) { // Check if not disabled
                e.preventDefault(); // Prevent default newline on Enter
                sendButton.click();
            }
        });

        // --- Initialization ---
        log("챗봇 초기화 완료. API 키 로드됨 (config.js).");
        userInput.focus(); // Focus input field on load

    </script>
</body>
</html>
