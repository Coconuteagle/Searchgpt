<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>검색 기반 Gemini 챗봇</title> 
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <script src="config.js"></script> 
    <style>
        body {
            transition: background-color 0.3s, color 0.3s;
        }
        .dark {
            background-color: #1a202c;
            color: #e2e8f0;
        }
        .chat-container {
            height: calc(100vh - 180px); /* Adjusted for potential footer/header */
            min-height: 400px;
        }
        .user-message {
            background-color: #e3f2fd;
            border-radius: 18px 18px 2px 18px;
            margin-left: auto;
            margin-right: 0;
        }
        .bot-message {
            background-color: #f1f1f1;
            border-radius: 18px 18px 18px 2px;
            margin-left: 0;
            margin-right: auto;
        }
        .dark .user-message {
            background-color: #2d3748;
        }
        .dark .bot-message {
            background-color: #4a5568;
        }
        .progress-container {
            width: 100%;
            height: 8px;
            background-color: #e2e8f0;
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        .progress-bar {
            height: 100%;
            border-radius: 4px 0 0 4px;
            width: 0%;
            background-color: #4299e1;
            transition: width 0.3s ease-in-out;
        }
        .dark .progress-container {
            background-color: #2d3748;
        }
        .progress-status {
            margin-top: 5px;
            font-size: 12px;
            color: #718096;
            text-align: center;
        }
        .dark .progress-status {
            color: #a0aec0;
        }
        .source-link {
            color: #3182ce;
            text-decoration: underline;
            word-break: break-all;
        }
        .dark .source-link {
            color: #90cdf4;
        }
        .source-link:hover {
            text-decoration: none;
        }
        .ellipsis {
            display: inline-block;
            width: 60px;
            text-align: left;
        }
        .typing-dot {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: currentColor;
            margin-right: 4px;
            animation: typing 1s infinite;
        }
        .typing-dot:nth-child(2) {
            animation-delay: 0.2s;
        }
        .typing-dot:nth-child(3) {
            animation-delay: 0.4s;
        }
        @keyframes typing {
            0%, 100% { opacity: 0.3; transform: translateY(0); }
            50% { opacity: 1; transform: translateY(-2px); }
        }
        @media print {
            .no-print { display: none !important; }
            body { background-color: #fff; color: #000; }
            .dark { background-color: #fff; color: #000; }
            .dark .user-message, .dark .bot-message { background-color: #f1f1f1; color: #000; }
            .user-message, .bot-message { background-color: #f1f1f1; }
            .chat-container { height: auto; max-height: none; overflow: visible; }
            .source-link { color: #0000EE; text-decoration: underline; }
            .print-break { page-break-before: always; }
             #chat-form, #progress-section, #theme-toggle { display: none; }
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <div class="flex justify-between items-center mb-6 no-print">
            <h1 class="text-3xl font-bold text-gray-800 dark:text-white">검색 기반 Gemini 챗봇</h1>
            <div class="flex space-x-4">
                <button id="theme-toggle" class="px-3 py-2 bg-gray-500 text-white rounded-md hover:bg-gray-600 transition focus:outline-none focus:ring-2 focus:ring-gray-500">
                    <i class="fas fa-moon"></i> </button>
                 <button onclick="window.print()" class="px-3 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500">
                    <i class="fas fa-print"></i>
                </button>
            </div>
        </div>

        <div id="chat-box" class="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">
            <div id="chat-messages" class="chat-container p-4 overflow-y-auto space-y-4">
                <div class="bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl">
                    <p>안녕하세요! 검색 기반 Gemini 챗봇입니다. 궁금한 점이 있으시면 질문해주세요. 제가 구글 검색과 웹페이지 분석(실패 시 요약 정보 활용)을 통해 답변해 드리겠습니다.</p>
                </div>
            </div>

            <div id="chat-form" class="p-4 border-t border-gray-200 dark:border-gray-700 bg-gray-50 dark:bg-gray-900 no-print">
                <div class="max-w-3xl mx-auto">
                    <div id="progress-section" class="mb-3 hidden">
                        <div id="progress-status" class="progress-status"></div>
                        <div class="progress-container">
                            <div id="progress-bar" class="progress-bar"></div>
                        </div>
                    </div>
                    <div class="flex space-x-2">
                        <input type="text" id="user-input" class="flex-grow px-4 py-2 border border-gray-300 dark:border-gray-600 rounded-l-md shadow-sm focus:outline-none focus:ring-blue-500 focus:border-blue-500 dark:bg-gray-700 dark:text-white" placeholder="질문을 입력하세요...">
                        <button id="send-button" class="px-4 py-2 bg-blue-500 text-white rounded-r-md hover:bg-blue-600 transition focus:outline-none focus:ring-2 focus:ring-blue-500 disabled:opacity-50" aria-label="Send message">
                            <i class="fas fa-paper-plane"></i>
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <div class="mt-6 text-sm text-gray-600 dark:text-gray-400 text-center no-print">
            <p>© 2025 검색 기반 Gemini 챗봇 by 수현</p>
        </div>
    </div>

    <script>
        // --- Basic Setup ---
        const DEBUG = true; // Enable console logging
        function log(...args) {
            if (DEBUG) {
                const now = new Date();
                // Format time as HH:MM:SS.ms
                const timeString = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}.${now.getMilliseconds().toString().padStart(3, '0')}`;
                console.log(`[챗봇 로그 ${timeString}]`, ...args);
            }
        }

        // Check if API keys are loaded from config.js
        if (typeof apiKeys === 'undefined') {
            console.error("API Keys not found! Make sure config.js is loaded correctly and defines the 'apiKeys' object.");
            alert("API Keys 설정 파일을 찾을 수 없습니다. config.js 파일이 올바르게 로드되었는지 확인하세요.");
        }

        // --- DOM Elements ---
        const chatMessages = document.getElementById('chat-messages');
        const userInput = document.getElementById('user-input');
        const sendButton = document.getElementById('send-button');
        const progressSection = document.getElementById('progress-section');
        const progressBar = document.getElementById('progress-bar');
        const progressStatus = document.getElementById('progress-status');
        const themeToggleBtn = document.getElementById('theme-toggle');
        const body = document.body;

        // --- Dark Mode ---
        function applyTheme(isDark) {
            if (isDark) {
                body.classList.add('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-sun"></i>';
            } else {
                body.classList.remove('dark');
                themeToggleBtn.innerHTML = '<i class="fas fa-moon"></i>';
            }
        }
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');
        let currentModeIsDark = localStorage.getItem('dark-mode') === 'true' || (localStorage.getItem('dark-mode') === null && prefersDark.matches);
        applyTheme(currentModeIsDark);

        themeToggleBtn.addEventListener('click', () => {
            currentModeIsDark = !currentModeIsDark;
            localStorage.setItem('dark-mode', currentModeIsDark ? 'true' : 'false');
            applyTheme(currentModeIsDark);
        });
         prefersDark.addEventListener('change', (e) => {
             if (localStorage.getItem('dark-mode') === null) {
                currentModeIsDark = e.matches;
                applyTheme(currentModeIsDark);
             }
         });


        // --- Cache System ---
        const cache = {
            search: new Map(),
            crawl: new Map(),
            maxAge: 30 * 60 * 1000, // 30 minutes validity
            getSearch(query) {
                const item = this.search.get(query);
                if (item && (Date.now() - item.timestamp < this.maxAge)) {
                    log('Search cache hit:', query);
                    return item.data;
                }
                log('Search cache miss:', query);
                return null;
            },
            setSearch(query, data) {
                this.search.set(query, { data, timestamp: Date.now() });
                log('Search cache set:', query);
            },
            getCrawl(url) {
                const item = this.crawl.get(url);
                if (item && (Date.now() - item.timestamp < this.maxAge)) {
                    log('Crawl cache hit:', url);
                    return item.data;
                }
                log('Crawl cache miss:', url);
                return null;
            },
            setCrawl(url, data) {
                this.crawl.set(url, { data, timestamp: Date.now() });
                log('Crawl cache set:', url, 'Length:', data?.length);
            }
        };

        // --- UI Update Functions ---
        function escapeHtml(unsafe) {
            if (unsafe === null || typeof unsafe === 'undefined') return '';
             return unsafe
                 .toString()
                 .replace(/&/g, "&amp;")
                 .replace(/</g, "&lt;")
                 .replace(/>/g, "&gt;")
                 .replace(/"/g, "&quot;")
                 .replace(/'/g, "&#039;");
         }

        function addUserMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'user-message p-3 md:p-4 text-gray-800 dark:text-gray-200 max-w-3xl ml-auto mb-4';
            messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
        }

        function addBotMessage(message, isHTML = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-3 md:p-4 text-gray-800 dark:text-gray-200 max-w-3xl mr-auto mb-4';
            if (isHTML) {
                 // Basic sanitization (replace with DOMPurify if possible)
                 const sanitizedHTML = message//.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/gi, ''); // Remove script tags if needed, be careful not to break intended HTML
                 messageDiv.innerHTML = sanitizedHTML;
            } else {
                messageDiv.innerHTML = `<p>${escapeHtml(message)}</p>`;
            }
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

         function addLoadingMessage() {
            const existingLoading = document.getElementById('loading-message');
            if (existingLoading) return existingLoading;

            const messageDiv = document.createElement('div');
            messageDiv.className = 'bot-message p-4 text-gray-800 dark:text-gray-200 max-w-3xl mr-auto mb-4';
            messageDiv.id = 'loading-message';
            // Add text node first
            messageDiv.appendChild(document.createTextNode(''));
            // Then add ellipsis span
            const loadingSpan = document.createElement('span');
            loadingSpan.className = 'ellipsis';
            for (let i = 0; i < 3; i++) {
                const dot = document.createElement('span');
                dot.className = 'typing-dot';
                loadingSpan.appendChild(dot);
            }
            messageDiv.appendChild(loadingSpan); // Add ellipsis span
            chatMessages.appendChild(messageDiv);
            scrollToBottom();
            return messageDiv;
        }

         function updateLoadingMessage(message) {
            let loadingMessage = document.getElementById('loading-message');
            if (!loadingMessage) {
                 loadingMessage = addLoadingMessage(); // Ensure it exists
            }
             // Update the text node (should be the first child)
             if (loadingMessage.childNodes.length > 0 && loadingMessage.childNodes[0].nodeType === Node.TEXT_NODE) {
                 loadingMessage.childNodes[0].nodeValue = escapeHtml(message) + ' ';
             } else {
                 // If structure is unexpected, reset it
                 loadingMessage.textContent = escapeHtml(message) + ' ';
                 const loadingSpan = document.createElement('span');
                 loadingSpan.className = 'ellipsis';
                  for (let i = 0; i < 3; i++) {
                      const dot = document.createElement('span');
                      dot.className = 'typing-dot';
                      loadingSpan.appendChild(dot);
                  }
                 loadingMessage.appendChild(loadingSpan);
             }
        }


        function removeLoadingMessage() {
            const loadingMessage = document.getElementById('loading-message');
            if (loadingMessage) {
                loadingMessage.remove();
            }
        }

        function updateProgress(percent, statusText) {
            const clampedPercent = Math.min(100, Math.max(0, percent));
            progressBar.style.width = `${clampedPercent}%`;
            progressStatus.textContent = statusText;

            if (clampedPercent > 0 && progressSection.classList.contains('hidden')) {
                progressSection.classList.remove('hidden');
            }

            if (clampedPercent >= 100) {
                setTimeout(() => {
                    // Check again before hiding, in case a new process started quickly
                    if (progressBar.style.width === '100%') {
                         progressSection.classList.add('hidden');
                         progressBar.style.width = '0%'; // Reset for next time
                         progressStatus.textContent = ''; // Clear status
                    }
                }, 1500); // Keep it visible for 1.5 seconds after 100%
            } else if (clampedPercent <= 0) {
                 // Hide immediately if progress is 0 or less
                 progressSection.classList.add('hidden');
                 progressBar.style.width = '0%';
                 progressStatus.textContent = '';
            }
        }

        function scrollToBottom() {
             // A small delay can help ensure rendering is complete before scrolling
             setTimeout(() => {
                chatMessages.scrollTop = chatMessages.scrollHeight;
             }, 50);
        }

         function setLoadingState(isLoading) {
            if (isLoading) {
                sendButton.disabled = true;
                userInput.disabled = true;
                sendButton.classList.add('disabled:opacity-50'); // Visual cue
                 addLoadingMessage(); // Show loading dots immediately
                 updateProgress(0, '시작 중...'); // Show progress bar immediately
            } else {
                sendButton.disabled = false;
                userInput.disabled = false;
                sendButton.classList.remove('disabled:opacity-50');
                 removeLoadingMessage();
                 // updateProgress handles hiding itself when >= 100%
            }
        }


        // --- Google Search API Call ---
        async function googleSearch(query) {
            const googleApiKey = apiKeys?.GOOGLE_API_KEY;
            const searchEngineId = apiKeys?.SEARCH_ENGINE_ID;
            if (!googleApiKey || !searchEngineId) {
                 throw new Error("Google Search API Key or Search Engine ID is missing in config.js");
            }

            updateProgress(10, '구글 검색 중...');
            const cachedResults = cache.getSearch(query);
            if (cachedResults) {
                updateProgress(20, '캐시된 검색 결과 사용 중...');
                return cachedResults;
            }

            try {
                const apiUrl = `https://www.googleapis.com/customsearch/v1?key=${googleApiKey}&cx=${searchEngineId}&q=${encodeURIComponent(query)}&num=8`; // Fetch 8 results
                log("Google Search API Request:", apiUrl);
                const response = await fetch(apiUrl);
                const data = await response.json();

                if (!response.ok || data.error) {
                    log('Google Search API Error:', data.error || `HTTP ${response.status} ${response.statusText}`);
                    throw new Error(`Google 검색 API 오류: ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }
                updateProgress(20, '검색 결과 처리 중...');
                if (!data.items || data.items.length === 0) {
                     log("Google Search: 결과 없음");
                    return [];
                }
                // Extract relevant fields including snippet
                const results = data.items.map(item => ({
                    title: item.title,
                    link: item.link,
                    snippet: item.snippet, // Ensure snippet is captured
                    pagemap: item.pagemap // Might be useful for metadata later
                }));
                cache.setSearch(query, results); // Cache successful results
                return results;
            } catch (error) {
                log('Google 검색 중 예외 발생:', error.message, error.stack);
                throw error; // Re-throw to be caught by processMessage
            }
        }

        // --- Web Crawling ---

        const PROXY_COOLDOWN_MS = 3 * 60 * 1000; // 3 minutes cooldown period

        const proxies = [
             // Add cooldownUntil property to each proxy
             { name: 'corsproxy.io', url: (targetUrl) => `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`, cooldownUntil: 0 },
             { name: 'allorigins', url: (targetUrl) => `https://api.allorigins.win/raw?url=${encodeURIComponent(targetUrl)}`, cooldownUntil: 0 },
             // Add more proxies here if needed, each with cooldownUntil: 0
        ];

        async function crawlWebpage(url, attempt = 0) {
            const cachedContent = cache.getCrawl(url);
            if (cachedContent) {
                return cachedContent;
            }

            // Filter available proxies (not on cooldown)
            const availableProxies = proxies.filter(p => Date.now() >= (p.cooldownUntil || 0));

            if (availableProxies.length === 0) {
                const soonestAvailable = proxies.reduce((soonest, p) => ((p.cooldownUntil || 0) < (soonest.cooldownUntil || 0) ? p : soonest), proxies[0]);
                const waitTime = soonestAvailable ? Math.ceil(((soonestAvailable.cooldownUntil || 0) - Date.now()) / 1000) : 'N/A';
                log(`크롤링 실패: 모든 프록시가 현재 쿨다운 중. URL: ${url}. 다음 활성화까지 약 ${waitTime}초`);
                return `크롤링 실패 (모든 프록시 쿨다운 중, 약 ${waitTime}초 후 재시도 가능): ${url}`;
            }

            const maxRetriesForUrl = availableProxies.length; // Max attempts = number of currently usable proxies
            if (attempt >= maxRetriesForUrl) {
                log(`크롤링 최대 재시도 도달 (${maxRetriesForUrl}회). URL: ${url}`);
                return `크롤링 실패 (최대 재시도): ${url}`;
            }

            // Select the next available proxy based on the attempt number
            const proxy = availableProxies[attempt];
            log(`[${proxy.name}] 크롤링 시도 (${attempt + 1}/${maxRetriesForUrl}): ${url}`);

            try {
                if (!url || !url.startsWith('http')) {
                    log(`[${proxy.name}] 크롤링 건너뜀 (유효하지 않은 URL): ${url}`);
                    throw new Error(`유효하지 않은 URL: ${url}`);
                }
                 const path = url.split('?')[0];
                 const fileExtension = path.includes('.') ? path.split('.').pop().toLowerCase() : '';
                const nonHtmlExtensions = ['pdf', 'doc', 'docx', 'ppt', 'pptx', 'xls', 'xlsx', 'zip', 'rar', 'jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'mp3', 'mp4', 'avi', 'mov', 'exe', 'dmg'];
                if (nonHtmlExtensions.includes(fileExtension)) {
                     log(`[${proxy.name}] 크롤링 건너뜀 (파일 형식 ${fileExtension}): ${url}`);
                    return `크롤링 건너뜀 (파일 형식 ${fileExtension.toUpperCase()}): ${url}`;
                }

                const controller = new AbortController();
                const timeoutId = setTimeout(() => {
                    controller.abort();
                    log(`[${proxy.name}] 타임아웃 (15s) 발생. URL: ${url}`);
                 }, 15000); // 15-second timeout

                const proxyUrl = proxy.url(url);
                const headers = {
                    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36',
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'ko-KR,ko;q=0.9,en-US;q=0.8,en;q=0.7',
                    'Upgrade-Insecure-Requests': '1',
                     'Sec-Fetch-Dest': 'document',
                     'Sec-Fetch-Mode': 'navigate',
                     'Sec-Fetch-Site': 'cross-site',
                };

                const response = await fetch(proxyUrl, {
                    signal: controller.signal,
                    headers: headers,
                    mode: 'cors',
                    referrerPolicy: 'strict-origin-when-cross-origin'
                 });
                clearTimeout(timeoutId); // Clear timeout if fetch completes

                if (!response.ok) {
                     let errorBody = '';
                     try { errorBody = await response.text(); } catch (_) {}
                     log(`[${proxy.name}] HTTP 오류 ${response.status} (${response.statusText}). URL: ${url}. 응답 일부: ${errorBody.substring(0, 200)}...`);
                     throw new Error(`HTTP 오류 ${response.status}`);
                }

                const contentType = response.headers.get('content-type') || '';
                 log(`[${proxy.name}] 응답 Content-Type: ${contentType}. URL: ${url}`);
                 if (!contentType.includes('text/html') && !contentType.includes('application/xhtml+xml') && !contentType.includes('text/plain')) {
                    if (contentType.includes('application/json')) {
                        try {
                            const json = await response.json();
                            const textContent = `JSON 데이터:\n${JSON.stringify(json, null, 2)}`.substring(0, 8000);
                            cache.setCrawl(url, textContent);
                            log(`[${proxy.name}] JSON 데이터 처리 완료. URL: ${url}`);
                            return textContent;
                        } catch (e) {
                            log(`[${proxy.name}] JSON 파싱 오류. Content-Type: ${contentType}, URL: ${url}`, e);
                            return `JSON 파싱 오류. Content-Type: ${contentType}, URL: ${url}`;
                        }
                     } else if (contentType.includes('xml') && !contentType.includes('xhtml')) { // Handle general XML
                         try {
                             const xmlText = await response.text();
                             const textContent = `XML 데이터:\n${xmlText}`.substring(0, 8000);
                              cache.setCrawl(url, textContent); // Cache XML content
                             log(`[${proxy.name}] XML 데이터 처리 완료. URL: ${url}`);
                             return textContent;
                         } catch (e) {
                             log(`[${proxy.name}] XML 파싱 오류. Content-Type: ${contentType}, URL: ${url}`, e);
                             return `XML 파싱 오류. Content-Type: ${contentType}, URL: ${url}`;
                         }
                     }
                     log(`[${proxy.name}] 지원하지 않는 Content-Type: ${contentType}, URL: ${url}`);
                     return `지원하지 않는 콘텐츠 타입 (${contentType}): ${url}`;
                 }

                const html = await response.text();
                if (!html || html.trim().length === 0) {
                    log(`[${proxy.name}] 빈 응답 또는 내용 없음. URL: ${url}`);
                    throw new Error('빈 응답 또는 내용 없음');
                }

                 // --- HTML Parsing and Content Extraction ---
                 const parser = new DOMParser();
                 const doc = parser.parseFromString(html, 'text/html');
                 const title = doc.querySelector('title')?.textContent.trim() || url;
                 const metaDescription = doc.querySelector('meta[name="description"]')?.getAttribute('content')?.trim() || '';
                 // Remove common non-content elements aggressively
                 const elementsToRemove = ['script', 'style', 'svg', 'img', 'picture', 'video', 'audio', 'iframe', 'nav', 'header', 'footer', 'aside', 'form', 'noscript', 'button', 'input', 'select', 'textarea', 'label', 'canvas', 'map', 'object', 'embed', '.advertisement', '.ad', '#ad', '.banner', '.popup', '.modal', '.sidebar', '.social-links', '.share-buttons', '.cookie-consent', '[aria-hidden="true"]'];
                 elementsToRemove.forEach(selector => {
                     try { // Add try-catch for potentially invalid selectors
                         doc.querySelectorAll(selector).forEach(el => el.remove());
                     } catch (e) {
                         log(`[${proxy.name}] CSS Selector 오류 무시 (${selector}), URL: ${url}:`, e.message);
                     }
                 });

                 // Attempt to find the main content area
                  let mainContent = doc.querySelector('main') ||
                                   doc.querySelector('article') ||
                                   doc.querySelector('[role="main"]') ||
                                   doc.querySelector('.content, .main-content, .post-content, .entry-content, #content, #main, .article-body, .entry, .page-content'); // Added more selectors

                 if (!mainContent || mainContent.textContent.trim().length < 100) { // Fallback if main is too small or not found
                     log(`[${proxy.name}] Main content 작거나 없음, body 사용. URL: ${url}`);
                     mainContent = doc.body;
                 }

                 // Extract text content, trying to preserve structure somewhat
                  let text = '';
                  const significantTags = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre', 'div', 'td']; // Add div, td
                  function extractTextNodes(node) {
                      let nodeText = '';
                      if (!node) return ''; // Guard against null nodes
                      for (const child of node.childNodes) {
                          if (child.nodeType === Node.TEXT_NODE) {
                              nodeText += child.textContent;
                          } else if (child.nodeType === Node.ELEMENT_NODE) {
                               const tagName = child.tagName.toLowerCase();
                               let displayStyle = 'inline'; // Default
                               try { // getComputedStyle can fail in some contexts
                                   displayStyle = window.getComputedStyle(child).display;
                               } catch (e) {
                                    log(`[${proxy.name}] getComputedStyle 오류 무시 (${tagName}), URL: ${url}:`, e.message);
                                    // Fallback for block-level tags if style check fails
                                    if (['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'blockquote', 'pre', 'div', 'td', 'tr', 'ul', 'ol', 'section', 'article', 'aside', 'nav', 'header', 'footer'].includes(tagName)) {
                                        displayStyle = 'block';
                                    }
                               }

                               if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && text.length > 0 && !text.endsWith('\n')) {
                                  nodeText += '\n';
                              }
                              nodeText += extractTextNodes(child); // Recurse
                               if ((significantTags.includes(tagName) || displayStyle.includes('block') || displayStyle.includes('list-item')) && !nodeText.endsWith('\n')) {
                                  nodeText += '\n';
                              }
                          }
                      }
                      return nodeText;
                  }

                 text = extractTextNodes(mainContent);


                 // Clean up extracted text
                 text = text.replace(/(\s*\n\s*){3,}/g, '\n\n') // Reduce multiple blank lines to max 2
                            .replace(/[ \t]{2,}/g, ' ')      // Reduce multiple spaces/tabs to one space
                            .replace(/^\s+|\s+$/gm, '')     // Trim whitespace from each line
                            .trim();                         // Trim leading/trailing whitespace from the whole string

                 // Add Title and Description at the beginning
                  text = `제목: ${title}\n${metaDescription ? '설명: ' + metaDescription + '\n' : ''}\n---\n\n${text}`;


                 // Check length and truncate if necessary
                 const maxLength = 8000;
                 if (text.length > maxLength) {
                     text = text.substring(0, maxLength) + '... [내용 중략됨]';
                     log(`[${proxy.name}] 크롤링 내용 축약됨 (>${maxLength} chars). URL: ${url}`);
                 }

                 if (!text || text.length < 50) { // Check if extracted text is meaningful
                     log(`[${proxy.name}] 유의미한 내용 추출 부족 (길이 ${text.length}). URL: ${url}`);
                     // Return potentially short text, let Gemini decide usability
                 }

                 log(`[${proxy.name}] 크롤링 성공. URL: ${url}, 길이: ${text.length}`);
                 cache.setCrawl(url, text); // Cache the processed text
                 // No need to reactivate proxies here, cooldown handles availability
                 return text;

            } catch (error) {
                log(`[${proxy.name}] '${url}' 크롤링 중 예외 발생 (시도 ${attempt + 1}/${maxRetriesForUrl}):`, error.message, error.stack);

                // Set cooldown for the failed proxy
                proxy.cooldownUntil = Date.now() + PROXY_COOLDOWN_MS;
                log(`[${proxy.name}] 프록시 쿨다운 설정됨 (${PROXY_COOLDOWN_MS / 1000}초). URL: ${url}`);

                // Retry with the next available proxy (increment attempt)
                return crawlWebpage(url, attempt + 1);
            }
        }


        // Parallel Web Crawling Function
        async function crawlWebpages(pagesToCrawl) {
            const totalSites = pagesToCrawl.length;
            updateProgress(30, `웹페이지 분석 시작 (0/${totalSites})...`);
            log(`${totalSites}개 사이트 크롤링/분석 시작`);

            let completedCount = 0;
            const crawlPromises = pagesToCrawl.map(async (pageInfo, index) => {
                 try {
                     const content = await crawlWebpage(pageInfo.link); // Start attempt 0
                      completedCount++;
                     updateProgress(30 + Math.floor(completedCount * 40 / totalSites), `${totalSites}개 중 ${completedCount}개 사이트 분석 완료`);
                     log(`사이트 ${index + 1}/${totalSites} 분석 완료 (성공 또는 최종 실패 메시지 포함): ${pageInfo.link}, 결과 길이: ${content?.length}`);
                     return { ...pageInfo, content, status: 'fulfilled' };
                 } catch (error) {
                     // This outer catch is less likely now but good as a fallback
                     log(`crawlWebpages 내 예외 발생 (사이트 ${pageInfo.link}):`, error.message, error.stack);
                     completedCount++;
                     updateProgress(30 + Math.floor(completedCount * 40 / totalSites), `${totalSites}개 중 ${completedCount}개 사이트 분석 완료 (오류 포함)`);
                     return { ...pageInfo, content: `크롤링 중 예상치 못한 오류: ${error.message}`, status: 'rejected' };
                 }
            });

            const results = await Promise.allSettled(crawlPromises);
             log('모든 사이트 크롤링/분석 시도 완료 (Promise.allSettled 완료)');
            updateProgress(70, '분석 완료, 응답 생성 준비 중...');

             // Process results
             return results.map((result, index) => {
                 if (result.status === 'fulfilled') {
                     log(`Promise 결과 ${index + 1}: 성공, URL: ${result.value.link}, Status: ${result.value.status}, Content 시작: ${result.value.content?.substring(0, 50)}...`);
                     return result.value;
                 } else {
                     const reason = result.reason || '알 수 없는 거부 사유';
                     const errorMessage = reason.message || reason.toString();
                     const originalPageInfo = pagesToCrawl[index] || { link: 'unknown', title: 'Unknown Error', snippet: '' };
                     log(`Promise 결과 ${index + 1}: 실패. URL: ${originalPageInfo.link}. 이유: ${errorMessage}`);
                     return {
                         ...originalPageInfo,
                         content: `크롤링 실패: ${errorMessage}`, // Provide the error message
                         status: 'rejected'
                      };
                 }
             });
        }

        // --- Google Gemini API Call ---

        // Helper function to escape regex special characters
        function escapeRegExp(string) {
          // . * + ? ^ $ { } ( ) | [ ] \ 문자를 이스케이프 처리
          return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'); // $&는 일치하는 전체 문자열을 의미
        }

        async function getGeminiResponse(question, processedResults) {
            const geminiApiKey = apiKeys?.GEMINI_API_KEY;
            if (!geminiApiKey) {
                throw new Error("Gemini API Key is missing in config.js");
            }

            updateProgress(75, 'Gemini 응답 생성 중...');
            log('Gemini 요청 준비 중...');

            let context = '';
            const validSourcesForPrompt = [];
            processedResults.forEach((result, index) => {
                const sourceNum = index + 1; // Consistent numbering based on original search results
                const isFailure = result.content?.startsWith('크롤링 실패') || result.content?.startsWith('크롤링 건너뜀') || result.content?.startsWith('지원하지 않는 콘텐츠 타입') || result.content?.startsWith('[정보 없음]');
                const isSnippetFallback = result.content?.startsWith('[스니펫 요약]');

                if ((!isFailure || isSnippetFallback) && result.content && result.content.trim() !== '') {
                    log(`Gemini 컨텍스트 추가됨 (출처 ${sourceNum}): ${result.title}, 내용 시작: ${result.content.substring(0, 100)}...`);
                    context += `[출처 ${sourceNum}: ${result.title}]\n${result.content}\n\n---\n\n`;
                    validSourcesForPrompt.push({...result, sourceNum});
                } else {
                    log(`Gemini 컨텍스트에서 제외된 출처 ${sourceNum} (${result.title}): ${result.content ? '내용 부적절/실패: ' + result.content.substring(0,100) + '...' : '내용 없음'}`);
                }
            });


            if (!context) {
                 log("Gemini 요청 취소: 유효한 컨텍스트 정보 없음 (크롤링/스니펫 모두 실패 또는 내용 부적절)");
                 updateProgress(100, '유효 정보 없음');
                 return "웹사이트에서 관련 정보를 찾거나 분석할 수 없었습니다. 다른 질문을 시도해 보세요.";
            }

            const systemInstruction = `당신은 제공된 웹 검색 결과(출처)를 바탕으로 사용자 질문에 답변하는 AI 챗봇입니다.
- 각 출처는 '[출처 번호: 제목]' 형식으로 시작하며, 내용은 전체 웹페이지 텍스트, JSON/XML 데이터 요약, 또는 '[스니펫 요약]'으로 시작하는 짧은 요약일 수 있습니다.
- 내용을 분석하여 사용자의 질문에 대해 정확하고 상세하게, 한국어로 답변하세요.
- 답변 내용 중 특정 출처를 참고한 부분이 있다면, 해당 문장 끝에 '[출처 번호]' 형식으로 반드시 명시하세요. (예: ... 입니다 [출처 1].)
- 여러 출처를 종합한 경우, 관련된 모든 출처 번호를 명시하세요. (예: ... 입니다 [출처 1][출처 3].)
- 출처 내용만으로 답변하기 어렵거나 정보가 부족하면, "제공된 정보만으로는 답변하기 어렵습니다." 또는 "정보가 부족합니다." 라고 솔직하게 답변하세요. 추측하거나 외부 지식을 사용하지 마세요.
- 답변 마지막에는 "참고 자료:" 섹션을 만들고, 답변 생성에 '실제로 사용된' 모든 출처의 번호, 제목, 원본 링크를 목록 형식으로 제공하세요. (예: * 출처 1: [제목] - [링크])`;

             const requestPayload = {
                contents: [{
                    role: "user",
                    parts: [{ text: `System Instructions:\n${systemInstruction}\n\n---\n\n사용자 질문:\n${question}\n\n---\n\n웹 검색 결과 (참고 자료):\n${context}` }]
                }],
                safetySettings: [
                  { category: "HARM_CATEGORY_HARASSMENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_HATE_SPEECH", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_SEXUALLY_EXPLICIT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                  { category: "HARM_CATEGORY_DANGEROUS_CONTENT", threshold: "BLOCK_MEDIUM_AND_ABOVE" },
                ],
                generationConfig: { temperature: 0.6 }
            };

            const model = "gemini-1.5-flash-latest"; // Consider gemini-pro for potentially better results on complex tasks
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${geminiApiKey}`;

            log('Gemini API 요청 전송:', apiUrl);
            // Avoid logging the full payload in production due to potentially large context size
            // if (DEBUG) { log('Gemini 요청 본문 (일부):', JSON.stringify(requestPayload).substring(0, 500) + '...'); }

            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestPayload)
                });
                const data = await response.json();

                if (!response.ok || data.error) {
                    log('Gemini API 오류 응답:', response.status, response.statusText, JSON.stringify(data));
                    throw new Error(`Gemini API 오류: ${data.error ? data.error.message : `HTTP ${response.status}`}`);
                }

                if (!data.candidates || data.candidates.length === 0 || !data.candidates[0].content) {
                    const feedback = data.promptFeedback || data.candidates?.[0]?.finishReason;
                    log('Gemini 응답 없음 또는 안전 필터링:', JSON.stringify(feedback), JSON.stringify(data.candidates?.[0]?.safetyRatings));
                    const reason = data.candidates?.[0]?.finishReason || data.promptFeedback?.blockReason || 'Unknown';
                    let message = `Gemini가 응답을 생성하지 못했습니다. 이유: ${reason}.`;
                    if (data.promptFeedback?.safetyRatings) {
                         message += ` (안전 평가: ${data.promptFeedback.safetyRatings.map(r => `${r.category}: ${r.probability}`).join(', ')})`;
                    }
                     updateProgress(100, '응답 생성 실패 (필터링)');
                     return message; // Return this specific message instead of throwing an error
                 }


                updateProgress(100, '응답 생성 완료');
                log('Gemini 응답 받음');
                let answer = data.candidates[0].content.parts[0].text;

                 // --- Post-processing Gemini Response ---

                 // 1. Link Citations: Replace [출처 N] with actual links
                 validSourcesForPrompt.forEach(source => {
                     const citationRegex = new RegExp(`\\[출처\\s?${source.sourceNum}\\]`, 'g');
                     const sourceLink = `<a href="${escapeHtml(source.link)}" target="_blank" class="source-link" title="${escapeHtml(source.title)}">[출처 ${source.sourceNum}]</a>`;
                     answer = answer.replace(citationRegex, sourceLink);
                 });

                 // 2. Link "참고 자료" List (if generated by Gemini)
                 answer = answer.replace(/(\*?\s*출처\s*(\d+)\s*:\s*)(.*?)\s*-\s*(https?:\/\/[^\s<]+)/g, (match, prefix, num, title, link) => {
                     const source = validSourcesForPrompt.find(s => s.sourceNum === parseInt(num));
                     if (source) {
                          // Use the original link from our data for accuracy
                          return `${prefix.trim()} <a href="${escapeHtml(source.link)}" target="_blank" class="source-link">${escapeHtml(title.trim())}</a>`;
                     }
                     return match; // Return original if source not found
                 });

                 // 3. Fallback attempt to link titles if the format is slightly different (using escapeRegExp)
                 validSourcesForPrompt.forEach(source => {
                      // FIX: Escape regex characters in the title *before* creating the RegExp
                      const escapedTitleForRegex = escapeRegExp(escapeHtml(source.title)); // Escape HTML first, then regex
                      // Create RegExp with the escaped title
                      const titleRegex = new RegExp(`(${escapedTitleForRegex})`, 'g');

                      // Only replace if not already inside an <a> tag
                      answer = answer.replace(titleRegex, (match, capturedTitle) => {
                          // Very basic check to avoid nested links
                           const surroundingChars = answer.substring(answer.indexOf(match) - 10, answer.indexOf(match) + match.length + 10);
                           if (surroundingChars.includes('<a href')) { return capturedTitle; } // Already linked likely
                           // Ensure capturedTitle uses the original (non-regex-escaped) formatting for display
                           return `<a href="${escapeHtml(source.link)}" target="_blank" class="source-link">${escapeHtml(source.title)}</a>`; // Use original title for display text
                      });
                 });


                 // 4. Basic Markdown to HTML conversion
                 answer = answer.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); // Bold
                 answer = answer.replace(/\*(.*?)\*/g, '<em>$1</em>');   // Italics
                 answer = answer.replace(/`([^`]+)`/g, '<code>$1</code>'); // Inline code
                 // Convert Markdown headings (basic)
                 answer = answer.replace(/^###+\s+(.*)/gm, '<h5>$1</h5>');
                 answer = answer.replace(/^##\s+(.*)/gm, '<h4>$1</h4>');
                 answer = answer.replace(/^#\s+(.*)/gm, '<h3>$1</h3>');
                 // Convert Markdown lists (basic)
                  answer = answer.replace(/^\s*[\-\*]\s+(.*)/gm, '<li>$1</li>');
                  answer = answer.replace(/(<li>.*?<\/li>\s*)+/g, (match) => `<ul>${match}</ul>`); // Wrap consecutive LIs in UL
                 // Convert newlines to <br> (do this carefully after list processing)
                  // Avoid adding <br> inside or directly adjacent to list tags
                  answer = answer.replace(/<\/ul>\s*<br>/g, '</ul>'); // Remove breaks after UL
                  answer = answer.replace(/<br>\s*<ul>/g, '<ul>');    // Remove breaks before UL
                  answer = answer.replace(/<li>\s*<br>/g, '<li>');    // Remove breaks at start of LI
                  answer = answer.replace(/<br>\s*<\/li>/g, '</li>');  // Remove breaks at end of LI
                  // Convert remaining newlines, but not those directly after a block element closing tag
                  answer = answer.replace(/(\/h[1-6]>|\/p>|\/div>|\/blockquote>|\/pre>|</ul>|<\/ol>|<\/li>)\s*\n/g, '$1'); // Remove newline after block elements
                  answer = answer.replace(/\n/g, '<br>'); // Convert remaining newlines

                 return answer;

            } catch (error) {
                log('Gemini 응답 생성/처리 중 예외 발생:', error.message, error.stack);
                updateProgress(100, '응답 처리 중 오류 발생');
                // Return the error message to be displayed by the bot
                return `Gemini 응답 처리 중 오류 발생: ${error.message}`;
            }
        }

        // --- Main Message Processing Orchestrator ---
        async function processMessage(message) {
             addUserMessage(message); // Add user message immediately
             setLoadingState(true);

            try {
                // 1. Google Search
                updateLoadingMessage('Google 검색 중...');
                const searchResults = await googleSearch(message);
                if (!searchResults || searchResults.length === 0) {
                    addBotMessage('관련 웹페이지를 찾을 수 없습니다. 다른 검색어나 질문을 시도해 보세요.');
                    updateProgress(100, '검색 결과 없음');
                     setLoadingState(false); // Re-enable input
                    return;
                }
                log("검색 결과:", searchResults.map(r => ({ link: r.link, title: r.title, snippet_exists: !!r.snippet })));

                // 2. Crawl Webpages
                updateLoadingMessage('웹페이지 정보 분석 중...');
                const pagesToCrawl = searchResults.map(r => ({
                    link: r.link,
                    title: r.title,
                    snippet: r.snippet // Pass snippet
                }));
                const crawledResults = await crawlWebpages(pagesToCrawl); // Results now include status and original data

                // 3. Apply Snippet Fallback & Prepare for Gemini
                updateLoadingMessage('분석 결과 정리 중...');
                const resultsForGemini = crawledResults.map((result, index) => {
                    // Check if crawling failed based on common failure messages or rejected status
                    const crawlFailed = result.status === 'rejected' || result.content?.startsWith('크롤링 실패') || result.content?.startsWith('크롤링 건너뜀') || result.content?.startsWith('지원하지 않는 콘텐츠 타입');
                    const hasSnippet = result.snippet && result.snippet.trim() !== '';

                    if (crawlFailed && hasSnippet) {
                        log(`크롤링 실패/건너뜀, 스니펫 사용: ${result.title} (URL: ${result.link})`);
                        // Keep original data, replace content with snippet fallback
                        return { ...result, content: `[스니펫 요약] ${result.snippet}`, status: 'fulfilled_with_snippet' }; // Mark status for clarity
                    } else if (crawlFailed) {
                        log(`크롤링 실패/부적합, 스니펫 없음: ${result.title} (URL: ${result.link})`);
                        // Mark as unusable, keep failure message in content for potential debugging/logging
                         return { ...result, content: `[정보 없음] ${result.content || '크롤링 실패'}`, status: 'rejected_no_snippet' };
                    } else {
                         // Crawl successful (or content was extracted even if short)
                         // Ensure status is 'fulfilled' if it came from crawlWebpage successfully
                         return { ...result, status: 'fulfilled' };
                    }
                }).map((result, index) => ({ ...result, sourceNum: index + 1 })); // Add sourceNum consistently at the end

                log("Gemini에게 전달할 최종 컨텐츠 후보 개수:", resultsForGemini.length);


                // 4. Get Gemini Response
                // Filter out results explicitly marked as unusable before sending to Gemini
                 const usableResultsForGemini = resultsForGemini.filter(r => r.status !== 'rejected_no_snippet');

                if (usableResultsForGemini.length > 0) {
                    updateLoadingMessage('Gemini 응답 생성 중...');
                    const geminiResponse = await getGeminiResponse(message, usableResultsForGemini);

                     removeLoadingMessage(); // Remove loading indicator *before* adding final response
                    const botMsgElement = addBotMessage(geminiResponse, true); // Render response as HTML

                    // 5. Append Original Search Results List (Optional)
                    const sourcesDiv = document.createElement('div');
                    sourcesDiv.className = 'mt-4 pt-4 border-t border-gray-200 dark:border-gray-700 text-sm text-gray-600 dark:text-gray-400 no-print';
                    // Use the *original* searchResults array for this list
                    let sourcesHtml = '<p class="font-medium mb-2">참고한 원본 검색 결과:</p><ul class="list-disc list-inside space-y-1">';
                    searchResults.forEach((result, index) => {
                        // Use original search results here
                        sourcesHtml += `<li>(${index + 1}) <a href="${escapeHtml(result.link)}" target="_blank" class="source-link hover:underline" title="${escapeHtml(result.snippet)}">${escapeHtml(result.title)}</a></li>`;
                    });
                    sourcesHtml += '</ul>';
                    sourcesDiv.innerHTML = sourcesHtml;

                    // Append sources to the last bot message element if it exists
                    if (botMsgElement) {
                         botMsgElement.appendChild(sourcesDiv);
                         scrollToBottom(); // Scroll again after adding sources
                    }

                } else {
                    // This happens if search succeeded but ALL crawls failed AND had no snippets
                     removeLoadingMessage();
                    log("처리 가능한 유효 정보 없음 (모든 크롤링/스니펫 실패)");
                    addBotMessage('웹사이트 정보를 분석하는 데 실패했고, 사용할 수 있는 요약 정보도 없습니다. 다른 질문을 시도해 보세요.');
                    updateProgress(100, '처리할 내용 없음');
                }

            } catch (error) {
                log('전체 처리 중 오류 발생:', error.message, error.stack);
                 removeLoadingMessage(); // Ensure loading is removed on error
                addBotMessage(`처리 중 오류가 발생했습니다: ${error.message}`);
                updateProgress(100, '오류 발생'); // Ensure progress completes on error
            } finally {
                 setLoadingState(false); // Re-enable input fields regardless of success/failure
                 // Ensure progress bar hides eventually
                 if (progressBar.style.width !== '100%') {
                      // Check if progress is still needed before forcing completion
                      const currentPercent = parseFloat(progressBar.style.width);
                      if (currentPercent < 100) {
                         setTimeout(() => updateProgress(100, progressStatus.textContent || '완료'), 200);
                      }
                 }
            }
        }

        // --- Event Listeners ---
        sendButton.addEventListener('click', () => {
            const message = userInput.value.trim();
            if (message && !sendButton.disabled) { // Check if not already processing
                userInput.value = '';
                userInput.focus();
                // processMessage now adds the user message
                processMessage(message);
            }
        });

        userInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey && !sendButton.disabled) { // Check if not disabled
                e.preventDefault(); // Prevent default newline on Enter
                sendButton.click();
            }
        });

        // --- Initialization ---
        log("챗봇 초기화 완료. 프록시 쿨다운, 상세 로깅, 정규식 오류 수정 적용됨.");
        userInput.focus(); // Focus input field on load

    </script>
</body>
</html>
